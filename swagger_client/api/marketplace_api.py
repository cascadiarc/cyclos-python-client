# coding: utf-8

"""
    Cyclos 4.11.5 API

    The REST API for Cyclos 4.11.5  # noqa: E501

    OpenAPI spec version: 4.11.5
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class MarketplaceApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def accept_order_by_buyer(self, order, **kwargs):  # noqa: E501
        """Accepts a pending order by buyer.  # noqa: E501

        Accepts a pending order by buyer generating the corresponding payment. The order status must be `pendingBuyer` to be  accepted by the authenticated user (i.e the buyer).  The `paymentType` and the `confirmationPassword` are required under the  following circumstances:  `paymentType`: Only required if the order was generated as a sale by the  seller and not from the shopping cart check-out (Sales are not supported yet).  `confirmationPassword`: Only required if at check-out a delivery method was  not set or its charge type is `negotiatied`.      The possible statuses after an order acceptance are: * `paymentPending`: if the generated payment is  awaiting for authorization;          * `completed`: if the payment was done.         # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accept_order_by_buyer(order, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str order: Either the order id or number. If the number is solely comprised of numbers, it must be prefixed by a single quote.  (required)
        :param str confirmation_password: The password used to confirm this action, if needed. The actual password type, if any, depends on the Cyclos configuration for the current channel. 
        :param AcceptOrderByBuyer params: The parameters for accepting the order.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.accept_order_by_buyer_with_http_info(order, **kwargs)  # noqa: E501
        else:
            (data) = self.accept_order_by_buyer_with_http_info(order, **kwargs)  # noqa: E501
            return data

    def accept_order_by_buyer_with_http_info(self, order, **kwargs):  # noqa: E501
        """Accepts a pending order by buyer.  # noqa: E501

        Accepts a pending order by buyer generating the corresponding payment. The order status must be `pendingBuyer` to be  accepted by the authenticated user (i.e the buyer).  The `paymentType` and the `confirmationPassword` are required under the  following circumstances:  `paymentType`: Only required if the order was generated as a sale by the  seller and not from the shopping cart check-out (Sales are not supported yet).  `confirmationPassword`: Only required if at check-out a delivery method was  not set or its charge type is `negotiatied`.      The possible statuses after an order acceptance are: * `paymentPending`: if the generated payment is  awaiting for authorization;          * `completed`: if the payment was done.         # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accept_order_by_buyer_with_http_info(order, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str order: Either the order id or number. If the number is solely comprised of numbers, it must be prefixed by a single quote.  (required)
        :param str confirmation_password: The password used to confirm this action, if needed. The actual password type, if any, depends on the Cyclos configuration for the current channel. 
        :param AcceptOrderByBuyer params: The parameters for accepting the order.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['order', 'confirmation_password', 'params']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accept_order_by_buyer" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'order' is set
        if self.api_client.client_side_validation and ('order' not in params or
                                                       params['order'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `order` when calling `accept_order_by_buyer`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'order' in params:
            path_params['order'] = params['order']  # noqa: E501

        query_params = []

        header_params = {}
        if 'confirmation_password' in params:
            header_params['confirmationPassword'] = params['confirmation_password']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'params' in params:
            body_params = params['params']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['accessClient', 'basic', 'session']  # noqa: E501

        return self.api_client.call_api(
            '/orders/{order}/buyer/accept', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def accept_order_by_seller(self, order, **kwargs):  # noqa: E501
        """Accepts a pending order by seller.  # noqa: E501

        Accepts a pending order by seller generating the corresponding payment. The order status must be `pendingSeller` to be  accepted by the authenticated user (i.e seller).  The possible statuses after an order acceptance are: * `paymentPending`: if the generated payment is  awaiting for authorization;         * `completed`: if the payment was done.         # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accept_order_by_seller(order, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str order: Either the order id or number. If the number is solely comprised of numbers, it must be prefixed by a single quote.  (required)
        :param AcceptOrderBySeller params: The parameters for accepting the order.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.accept_order_by_seller_with_http_info(order, **kwargs)  # noqa: E501
        else:
            (data) = self.accept_order_by_seller_with_http_info(order, **kwargs)  # noqa: E501
            return data

    def accept_order_by_seller_with_http_info(self, order, **kwargs):  # noqa: E501
        """Accepts a pending order by seller.  # noqa: E501

        Accepts a pending order by seller generating the corresponding payment. The order status must be `pendingSeller` to be  accepted by the authenticated user (i.e seller).  The possible statuses after an order acceptance are: * `paymentPending`: if the generated payment is  awaiting for authorization;         * `completed`: if the payment was done.         # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accept_order_by_seller_with_http_info(order, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str order: Either the order id or number. If the number is solely comprised of numbers, it must be prefixed by a single quote.  (required)
        :param AcceptOrderBySeller params: The parameters for accepting the order.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['order', 'params']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accept_order_by_seller" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'order' is set
        if self.api_client.client_side_validation and ('order' not in params or
                                                       params['order'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `order` when calling `accept_order_by_seller`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'order' in params:
            path_params['order'] = params['order']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'params' in params:
            body_params = params['params']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['accessClient', 'basic', 'session']  # noqa: E501

        return self.api_client.call_api(
            '/orders/{order}/seller/accept', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_item_to_shopping_cart(self, ad, **kwargs):  # noqa: E501
        """Adds the given webshop ad to the corresponding shopping cart.  # noqa: E501

        Adds the given webshop ad to the corresponding shopping cart according to the seller and currency and returns the total number of webshop ads in all carts. Optionally a quantity can be specified. The different shopping carts are created dynamically according to the seller and currency.     E.g if the user adds the following webshop ads (i.e items): * 1 from Seller1 in Dolars; * 2 from Seller1 in Euros; * 1 from Seller2 un Dolars.  Then the following three carts will be created for the authenticated user: * 1 cart containing 1 item offered by Seller1 in Dolars; * 1 cart containing 2 item offered by Seller1 in Euros; * 1 cart containing 1 item offered by Seller2 in Dolars.  Finally, the total number of wbshop ads returned will be 4.  For those quantity-limited products the given quantity could have been  adjusted to met the restrictions. You can view the adjustment applied to  each item when retrieving the details of a shopping cart. if you want to  remove the adjustment just send a new request to modify the quantity  (using `PUT /shopping-carts/items/{ad}`) and specify the current quantity  (i.e the already adjusted and returned in the details of the shopping cart) as the parameter.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_item_to_shopping_cart(ad, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ad: Can be either the advertisement internal identifier or, in case of webshop advertisements, can be the product number (if the owner is the logged user) or a string in the form `productNumber@user`, with the user identifier as well.       (required)
        :param float quantity: The quantity being added. It could be a decimal number only if the  corresponding webshop ad allows it. 
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_item_to_shopping_cart_with_http_info(ad, **kwargs)  # noqa: E501
        else:
            (data) = self.add_item_to_shopping_cart_with_http_info(ad, **kwargs)  # noqa: E501
            return data

    def add_item_to_shopping_cart_with_http_info(self, ad, **kwargs):  # noqa: E501
        """Adds the given webshop ad to the corresponding shopping cart.  # noqa: E501

        Adds the given webshop ad to the corresponding shopping cart according to the seller and currency and returns the total number of webshop ads in all carts. Optionally a quantity can be specified. The different shopping carts are created dynamically according to the seller and currency.     E.g if the user adds the following webshop ads (i.e items): * 1 from Seller1 in Dolars; * 2 from Seller1 in Euros; * 1 from Seller2 un Dolars.  Then the following three carts will be created for the authenticated user: * 1 cart containing 1 item offered by Seller1 in Dolars; * 1 cart containing 2 item offered by Seller1 in Euros; * 1 cart containing 1 item offered by Seller2 in Dolars.  Finally, the total number of wbshop ads returned will be 4.  For those quantity-limited products the given quantity could have been  adjusted to met the restrictions. You can view the adjustment applied to  each item when retrieving the details of a shopping cart. if you want to  remove the adjustment just send a new request to modify the quantity  (using `PUT /shopping-carts/items/{ad}`) and specify the current quantity  (i.e the already adjusted and returned in the details of the shopping cart) as the parameter.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_item_to_shopping_cart_with_http_info(ad, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ad: Can be either the advertisement internal identifier or, in case of webshop advertisements, can be the product number (if the owner is the logged user) or a string in the form `productNumber@user`, with the user identifier as well.       (required)
        :param float quantity: The quantity being added. It could be a decimal number only if the  corresponding webshop ad allows it. 
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ad', 'quantity']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_item_to_shopping_cart" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ad' is set
        if self.api_client.client_side_validation and ('ad' not in params or
                                                       params['ad'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `ad` when calling `add_item_to_shopping_cart`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ad' in params:
            path_params['ad'] = params['ad']  # noqa: E501

        query_params = []
        if 'quantity' in params:
            query_params.append(('quantity', params['quantity']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['accessClient', 'basic', 'session']  # noqa: E501

        return self.api_client.call_api(
            '/shopping-carts/items/{ad}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='int',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def adjust_and_get_shopping_cart_details(self, id, **kwargs):  # noqa: E501
        """Adjusts a shopping cart items, returning its details.  # noqa: E501

        Works like `GET /shopping-carts/{id}`, but first adjusts the status of all items. For each item checks both the availability and the quantity, setting to corresponding `availability` or `quantityAdjustment` property if anything was modified.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.adjust_and_get_shopping_cart_details(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The object identification (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :return: ShoppingCartView
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.adjust_and_get_shopping_cart_details_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.adjust_and_get_shopping_cart_details_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def adjust_and_get_shopping_cart_details_with_http_info(self, id, **kwargs):  # noqa: E501
        """Adjusts a shopping cart items, returning its details.  # noqa: E501

        Works like `GET /shopping-carts/{id}`, but first adjusts the status of all items. For each item checks both the availability and the quantity, setting to corresponding `availability` or `quantityAdjustment` property if anything was modified.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.adjust_and_get_shopping_cart_details_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The object identification (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :return: ShoppingCartView
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method adjust_and_get_shopping_cart_details" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `adjust_and_get_shopping_cart_details`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['accessClient', 'basic', 'session']  # noqa: E501

        return self.api_client.call_api(
            '/shopping-carts/{id}/adjust', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ShoppingCartView',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def checkout_shopping_cart(self, id, checkout, **kwargs):  # noqa: E501
        """Checks out a shopping cart.  # noqa: E501

        Checks out the given shopping cart associated to the authenticated user. After the check-out the purchase order will be awaiting for the seller's  acceptance (i. e with status `pendingSeller`).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.checkout_shopping_cart(id, checkout, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The object identification (required)
        :param ShoppingCartCheckout checkout: The data for check-out. (required)
        :param str confirmation_password: The password used to confirm this action, if needed. The actual password type, if any, depends on the Cyclos configuration for the current channel. 
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.checkout_shopping_cart_with_http_info(id, checkout, **kwargs)  # noqa: E501
        else:
            (data) = self.checkout_shopping_cart_with_http_info(id, checkout, **kwargs)  # noqa: E501
            return data

    def checkout_shopping_cart_with_http_info(self, id, checkout, **kwargs):  # noqa: E501
        """Checks out a shopping cart.  # noqa: E501

        Checks out the given shopping cart associated to the authenticated user. After the check-out the purchase order will be awaiting for the seller's  acceptance (i. e with status `pendingSeller`).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.checkout_shopping_cart_with_http_info(id, checkout, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The object identification (required)
        :param ShoppingCartCheckout checkout: The data for check-out. (required)
        :param str confirmation_password: The password used to confirm this action, if needed. The actual password type, if any, depends on the Cyclos configuration for the current channel. 
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'checkout', 'confirmation_password']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method checkout_shopping_cart" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `checkout_shopping_cart`")  # noqa: E501
        # verify the required parameter 'checkout' is set
        if self.api_client.client_side_validation and ('checkout' not in params or
                                                       params['checkout'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `checkout` when calling `checkout_shopping_cart`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'confirmation_password' in params:
            header_params['confirmationPassword'] = params['confirmation_password']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'checkout' in params:
            body_params = params['checkout']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['accessClient', 'basic', 'session']  # noqa: E501

        return self.api_client.call_api(
            '/shopping-carts/{id}/checkout', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='int',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_ad(self, user, advertisement, **kwargs):  # noqa: E501
        """Creates a new advertisement for the given user.  # noqa: E501

        Creates a new advertisement for the given user.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_ad(user, advertisement, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: Can be one of: * a user identification value, such as id, username, e-mail, phone, etc.   Id is always allowed, others depend on Cyclos configuration. Note that   a valid numeric value is always considered as id. For example, when   using another identification method that can be numeric only, prefix   the value with a single quote (like in Excel spreadsheets), for   example, `'1234567890`;     * `self` for the currently authenticated user.  (required)
        :param AdNew advertisement: The advertisement to be created. (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_ad_with_http_info(user, advertisement, **kwargs)  # noqa: E501
        else:
            (data) = self.create_ad_with_http_info(user, advertisement, **kwargs)  # noqa: E501
            return data

    def create_ad_with_http_info(self, user, advertisement, **kwargs):  # noqa: E501
        """Creates a new advertisement for the given user.  # noqa: E501

        Creates a new advertisement for the given user.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_ad_with_http_info(user, advertisement, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: Can be one of: * a user identification value, such as id, username, e-mail, phone, etc.   Id is always allowed, others depend on Cyclos configuration. Note that   a valid numeric value is always considered as id. For example, when   using another identification method that can be numeric only, prefix   the value with a single quote (like in Excel spreadsheets), for   example, `'1234567890`;     * `self` for the currently authenticated user.  (required)
        :param AdNew advertisement: The advertisement to be created. (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user', 'advertisement']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_ad" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user' is set
        if self.api_client.client_side_validation and ('user' not in params or
                                                       params['user'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user` when calling `create_ad`")  # noqa: E501
        # verify the required parameter 'advertisement' is set
        if self.api_client.client_side_validation and ('advertisement' not in params or
                                                       params['advertisement'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `advertisement` when calling `create_ad`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user' in params:
            path_params['user'] = params['user']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'advertisement' in params:
            body_params = params['advertisement']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['accessClient', 'basic', 'session']  # noqa: E501

        return self.api_client.call_api(
            '/{user}/marketplace', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_ad_question(self, ad, question, **kwargs):  # noqa: E501
        """Creates a new advertisement question.  # noqa: E501

        Creates a new question for an advertisement and associate it to the  authenticated user.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_ad_question(ad, question, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ad: Can be either the advertisement internal identifier or, in case of webshop advertisements, can be the product number (if the owner is the logged user) or a string in the form `productNumber@user`, with the user identifier as well.       (required)
        :param str question: (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_ad_question_with_http_info(ad, question, **kwargs)  # noqa: E501
        else:
            (data) = self.create_ad_question_with_http_info(ad, question, **kwargs)  # noqa: E501
            return data

    def create_ad_question_with_http_info(self, ad, question, **kwargs):  # noqa: E501
        """Creates a new advertisement question.  # noqa: E501

        Creates a new question for an advertisement and associate it to the  authenticated user.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_ad_question_with_http_info(ad, question, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ad: Can be either the advertisement internal identifier or, in case of webshop advertisements, can be the product number (if the owner is the logged user) or a string in the form `productNumber@user`, with the user identifier as well.       (required)
        :param str question: (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ad', 'question']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_ad_question" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ad' is set
        if self.api_client.client_side_validation and ('ad' not in params or
                                                       params['ad'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `ad` when calling `create_ad_question`")  # noqa: E501
        # verify the required parameter 'question' is set
        if self.api_client.client_side_validation and ('question' not in params or
                                                       params['question'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `question` when calling `create_ad_question`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ad' in params:
            path_params['ad'] = params['ad']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'question' in params:
            body_params = params['question']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['text/plain; charset=utf-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['accessClient', 'basic', 'session']  # noqa: E501

        return self.api_client.call_api(
            '/marketplace/{ad}/questions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_ad(self, ad, **kwargs):  # noqa: E501
        """Removes an advertisement.  # noqa: E501

        Removes an advertisement by id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ad(ad, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ad: Can be either the advertisement internal identifier or, in case of webshop advertisements, can be the product number (if the owner is the logged user) or a string in the form `productNumber@user`, with the user identifier as well.       (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_ad_with_http_info(ad, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_ad_with_http_info(ad, **kwargs)  # noqa: E501
            return data

    def delete_ad_with_http_info(self, ad, **kwargs):  # noqa: E501
        """Removes an advertisement.  # noqa: E501

        Removes an advertisement by id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ad_with_http_info(ad, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ad: Can be either the advertisement internal identifier or, in case of webshop advertisements, can be the product number (if the owner is the logged user) or a string in the form `productNumber@user`, with the user identifier as well.       (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ad']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_ad" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ad' is set
        if self.api_client.client_side_validation and ('ad' not in params or
                                                       params['ad'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `ad` when calling `delete_ad`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ad' in params:
            path_params['ad'] = params['ad']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['accessClient', 'basic', 'session']  # noqa: E501

        return self.api_client.call_api(
            '/marketplace/{ad}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_ad_question(self, id, **kwargs):  # noqa: E501
        """Removes an advertisement question.  # noqa: E501

        Removes an advertisement question created for the authenticated user.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ad_question(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The object identification (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_ad_question_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_ad_question_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_ad_question_with_http_info(self, id, **kwargs):  # noqa: E501
        """Removes an advertisement question.  # noqa: E501

        Removes an advertisement question created for the authenticated user.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ad_question_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The object identification (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_ad_question" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `delete_ad_question`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['accessClient', 'basic', 'session']  # noqa: E501

        return self.api_client.call_api(
            '/questions/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_ad_data_for_edit(self, ad, **kwargs):  # noqa: E501
        """Returns configuration data for editing an advertisement.  # noqa: E501

        Returns configuration data which can be used to edit an advertisement.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ad_data_for_edit(ad, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ad: Can be either the advertisement internal identifier or, in case of webshop advertisements, can be the product number (if the owner is the logged user) or a string in the form `productNumber@user`, with the user identifier as well.       (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :return: AdDataForEdit
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_ad_data_for_edit_with_http_info(ad, **kwargs)  # noqa: E501
        else:
            (data) = self.get_ad_data_for_edit_with_http_info(ad, **kwargs)  # noqa: E501
            return data

    def get_ad_data_for_edit_with_http_info(self, ad, **kwargs):  # noqa: E501
        """Returns configuration data for editing an advertisement.  # noqa: E501

        Returns configuration data which can be used to edit an advertisement.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ad_data_for_edit_with_http_info(ad, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ad: Can be either the advertisement internal identifier or, in case of webshop advertisements, can be the product number (if the owner is the logged user) or a string in the form `productNumber@user`, with the user identifier as well.       (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :return: AdDataForEdit
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ad', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ad_data_for_edit" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ad' is set
        if self.api_client.client_side_validation and ('ad' not in params or
                                                       params['ad'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `ad` when calling `get_ad_data_for_edit`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ad' in params:
            path_params['ad'] = params['ad']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/marketplace/{ad}/data-for-edit', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AdDataForEdit',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_ad_data_for_new(self, user, **kwargs):  # noqa: E501
        """Returns configuration data for creating a new advertisement for a user and kind.   # noqa: E501

        Returns data for creating a new advertisement for the given user. The `kind` should be informed. If not set, `simple` is assumed. Currently only `simple` advertisements can be created through this API.         # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ad_data_for_new(user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: Can be one of: * a user identification value, such as id, username, e-mail, phone, etc.   Id is always allowed, others depend on Cyclos configuration. Note that   a valid numeric value is always considered as id. For example, when   using another identification method that can be numeric only, prefix   the value with a single quote (like in Excel spreadsheets), for   example, `'1234567890`;     * `self` for the currently authenticated user.  (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :param str kind: The possible kinds of an advertisement Possible values are: * simple: A simple advertisement that can be viewed, but not directly bought * webshop: An advertisement that is part of an webshop. Can be bought, there is stock management, etc. 
        :return: AdDataForNew
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_ad_data_for_new_with_http_info(user, **kwargs)  # noqa: E501
        else:
            (data) = self.get_ad_data_for_new_with_http_info(user, **kwargs)  # noqa: E501
            return data

    def get_ad_data_for_new_with_http_info(self, user, **kwargs):  # noqa: E501
        """Returns configuration data for creating a new advertisement for a user and kind.   # noqa: E501

        Returns data for creating a new advertisement for the given user. The `kind` should be informed. If not set, `simple` is assumed. Currently only `simple` advertisements can be created through this API.         # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ad_data_for_new_with_http_info(user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: Can be one of: * a user identification value, such as id, username, e-mail, phone, etc.   Id is always allowed, others depend on Cyclos configuration. Note that   a valid numeric value is always considered as id. For example, when   using another identification method that can be numeric only, prefix   the value with a single quote (like in Excel spreadsheets), for   example, `'1234567890`;     * `self` for the currently authenticated user.  (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :param str kind: The possible kinds of an advertisement Possible values are: * simple: A simple advertisement that can be viewed, but not directly bought * webshop: An advertisement that is part of an webshop. Can be bought, there is stock management, etc. 
        :return: AdDataForNew
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user', 'fields', 'kind']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ad_data_for_new" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user' is set
        if self.api_client.client_side_validation and ('user' not in params or
                                                       params['user'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user` when calling `get_ad_data_for_new`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user' in params:
            path_params['user'] = params['user']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if 'kind' in params:
            query_params.append(('kind', params['kind']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/{user}/marketplace/data-for-new', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AdDataForNew',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_ad_data_for_search(self, **kwargs):  # noqa: E501
        """Returns configuration data for searching advertisements.  # noqa: E501

        Returns data needed on for a general advertisements search.    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ad_data_for_search(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :param str kind: Indicates the kind of advertisement that should be searched. When nothing is passed (default) all kinds will be searched. Possible values are: * simple: A simple advertisement that can be viewed, but not directly bought * webshop: An advertisement that is part of an webshop. Can be bought, there is stock management, etc. 
        :param bool brokered: If the authenticated is a broker, passing the `true` value will indicate the advertisements to be searched are from managed users of that broker. The default is `false`. 
        :return: AdDataForSearch
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_ad_data_for_search_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_ad_data_for_search_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_ad_data_for_search_with_http_info(self, **kwargs):  # noqa: E501
        """Returns configuration data for searching advertisements.  # noqa: E501

        Returns data needed on for a general advertisements search.    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ad_data_for_search_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :param str kind: Indicates the kind of advertisement that should be searched. When nothing is passed (default) all kinds will be searched. Possible values are: * simple: A simple advertisement that can be viewed, but not directly bought * webshop: An advertisement that is part of an webshop. Can be bought, there is stock management, etc. 
        :param bool brokered: If the authenticated is a broker, passing the `true` value will indicate the advertisements to be searched are from managed users of that broker. The default is `false`. 
        :return: AdDataForSearch
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'kind', 'brokered']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ad_data_for_search" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if 'kind' in params:
            query_params.append(('kind', params['kind']))  # noqa: E501
        if 'brokered' in params:
            query_params.append(('brokered', params['brokered']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/marketplace/data-for-search', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AdDataForSearch',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_ad_question(self, id, **kwargs):  # noqa: E501
        """Returns details of an advertisement question.  # noqa: E501

        Return detailed information of an advertisement question.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ad_question(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The object identification (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :return: AdQuestionView
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_ad_question_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_ad_question_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_ad_question_with_http_info(self, id, **kwargs):  # noqa: E501
        """Returns details of an advertisement question.  # noqa: E501

        Return detailed information of an advertisement question.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ad_question_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The object identification (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :return: AdQuestionView
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ad_question" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_ad_question`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['accessClient', 'basic', 'session']  # noqa: E501

        return self.api_client.call_api(
            '/questions/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AdQuestionView',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_data_for_set_delivery_method(self, order, **kwargs):  # noqa: E501
        """Returns configuration data to set delivery method data by seller.  # noqa: E501

        Returns configuration data to set delivery method data by seller of an  order given by id.    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_data_for_set_delivery_method(order, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str order: Either the order id or number. If the number is solely comprised of numbers, it must be prefixed by a single quote.  (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :return: OrderDataForSetDeliveryMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_data_for_set_delivery_method_with_http_info(order, **kwargs)  # noqa: E501
        else:
            (data) = self.get_data_for_set_delivery_method_with_http_info(order, **kwargs)  # noqa: E501
            return data

    def get_data_for_set_delivery_method_with_http_info(self, order, **kwargs):  # noqa: E501
        """Returns configuration data to set delivery method data by seller.  # noqa: E501

        Returns configuration data to set delivery method data by seller of an  order given by id.    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_data_for_set_delivery_method_with_http_info(order, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str order: Either the order id or number. If the number is solely comprised of numbers, it must be prefixed by a single quote.  (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :return: OrderDataForSetDeliveryMethod
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['order', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_data_for_set_delivery_method" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'order' is set
        if self.api_client.client_side_validation and ('order' not in params or
                                                       params['order'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `order` when calling `get_data_for_set_delivery_method`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'order' in params:
            path_params['order'] = params['order']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['accessClient', 'basic', 'session']  # noqa: E501

        return self.api_client.call_api(
            '/orders/{order}/seller/data-for-set-delivery', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OrderDataForSetDeliveryMethod',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_order_data_for_accept_by_buyer(self, order, **kwargs):  # noqa: E501
        """Returns configuration data for accept an order by buyer.  # noqa: E501

        Returns configuration data for accept an order given by id as the buyer.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_order_data_for_accept_by_buyer(order, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str order: Either the order id or number. If the number is solely comprised of numbers, it must be prefixed by a single quote.  (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :return: OrderDataForAcceptByBuyer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_order_data_for_accept_by_buyer_with_http_info(order, **kwargs)  # noqa: E501
        else:
            (data) = self.get_order_data_for_accept_by_buyer_with_http_info(order, **kwargs)  # noqa: E501
            return data

    def get_order_data_for_accept_by_buyer_with_http_info(self, order, **kwargs):  # noqa: E501
        """Returns configuration data for accept an order by buyer.  # noqa: E501

        Returns configuration data for accept an order given by id as the buyer.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_order_data_for_accept_by_buyer_with_http_info(order, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str order: Either the order id or number. If the number is solely comprised of numbers, it must be prefixed by a single quote.  (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :return: OrderDataForAcceptByBuyer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['order', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_order_data_for_accept_by_buyer" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'order' is set
        if self.api_client.client_side_validation and ('order' not in params or
                                                       params['order'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `order` when calling `get_order_data_for_accept_by_buyer`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'order' in params:
            path_params['order'] = params['order']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['accessClient', 'basic', 'session']  # noqa: E501

        return self.api_client.call_api(
            '/orders/{order}/buyer/data-for-accept', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OrderDataForAcceptByBuyer',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_shopping_cart_data_for_checkout(self, id, **kwargs):  # noqa: E501
        """Returns configuration data for check-out a shopping cart.  # noqa: E501

        Returns configuration data for check-out the given shopping cart by id.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_shopping_cart_data_for_checkout(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The object identification (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :return: ShoppingCartDataForCheckout
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_shopping_cart_data_for_checkout_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_shopping_cart_data_for_checkout_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_shopping_cart_data_for_checkout_with_http_info(self, id, **kwargs):  # noqa: E501
        """Returns configuration data for check-out a shopping cart.  # noqa: E501

        Returns configuration data for check-out the given shopping cart by id.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_shopping_cart_data_for_checkout_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The object identification (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :return: ShoppingCartDataForCheckout
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_shopping_cart_data_for_checkout" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_shopping_cart_data_for_checkout`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['accessClient', 'basic', 'session']  # noqa: E501

        return self.api_client.call_api(
            '/shopping-carts/{id}/data-for-checkout', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ShoppingCartDataForCheckout',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_shopping_cart_details(self, id, **kwargs):  # noqa: E501
        """Returns details of a shopping cart.  # noqa: E501

        Returns the details of a shopping cart by id with all webshop ads offered by the same seller and in the same currency.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_shopping_cart_details(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The object identification (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :return: ShoppingCartView
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_shopping_cart_details_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_shopping_cart_details_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_shopping_cart_details_with_http_info(self, id, **kwargs):  # noqa: E501
        """Returns details of a shopping cart.  # noqa: E501

        Returns the details of a shopping cart by id with all webshop ads offered by the same seller and in the same currency.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_shopping_cart_details_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The object identification (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :return: ShoppingCartView
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_shopping_cart_details" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_shopping_cart_details`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['accessClient', 'basic', 'session']  # noqa: E501

        return self.api_client.call_api(
            '/shopping-carts/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ShoppingCartView',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_shopping_carts(self, **kwargs):  # noqa: E501
        """Returns the shopping carts list.  # noqa: E501

        Returns the shopping carts for the authenticated user. Each cart contains  all webshop ads offered by the same seller and in the same currency.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_shopping_carts(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :return: list[ShoppingCartResult]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_shopping_carts_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_shopping_carts_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_shopping_carts_with_http_info(self, **kwargs):  # noqa: E501
        """Returns the shopping carts list.  # noqa: E501

        Returns the shopping carts for the authenticated user. Each cart contains  all webshop ads offered by the same seller and in the same currency.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_shopping_carts_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :return: list[ShoppingCartResult]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_shopping_carts" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['accessClient', 'basic', 'session']  # noqa: E501

        return self.api_client.call_api(
            '/shopping-carts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ShoppingCartResult]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_user_ads_data_for_search(self, user, **kwargs):  # noqa: E501
        """Returns configuration data for searching advertisements of a user.  # noqa: E501

        Returns data needed on for a user's advertisements search.    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_ads_data_for_search(user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: Can be one of: * a user identification value, such as id, username, e-mail, phone, etc.   Id is always allowed, others depend on Cyclos configuration. Note that   a valid numeric value is always considered as id. For example, when   using another identification method that can be numeric only, prefix   the value with a single quote (like in Excel spreadsheets), for   example, `'1234567890`;     * `self` for the currently authenticated user.  (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :param str kind: Indicates the kind of advertisement that should be searched. When nothing is passed (default) all kinds will be searched. Possible values are: * simple: A simple advertisement that can be viewed, but not directly bought * webshop: An advertisement that is part of an webshop. Can be bought, there is stock management, etc. 
        :return: UserAdsDataForSearch
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_user_ads_data_for_search_with_http_info(user, **kwargs)  # noqa: E501
        else:
            (data) = self.get_user_ads_data_for_search_with_http_info(user, **kwargs)  # noqa: E501
            return data

    def get_user_ads_data_for_search_with_http_info(self, user, **kwargs):  # noqa: E501
        """Returns configuration data for searching advertisements of a user.  # noqa: E501

        Returns data needed on for a user's advertisements search.    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_ads_data_for_search_with_http_info(user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: Can be one of: * a user identification value, such as id, username, e-mail, phone, etc.   Id is always allowed, others depend on Cyclos configuration. Note that   a valid numeric value is always considered as id. For example, when   using another identification method that can be numeric only, prefix   the value with a single quote (like in Excel spreadsheets), for   example, `'1234567890`;     * `self` for the currently authenticated user.  (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :param str kind: Indicates the kind of advertisement that should be searched. When nothing is passed (default) all kinds will be searched. Possible values are: * simple: A simple advertisement that can be viewed, but not directly bought * webshop: An advertisement that is part of an webshop. Can be bought, there is stock management, etc. 
        :return: UserAdsDataForSearch
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user', 'fields', 'kind']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user_ads_data_for_search" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user' is set
        if self.api_client.client_side_validation and ('user' not in params or
                                                       params['user'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user` when calling `get_user_ads_data_for_search`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user' in params:
            path_params['user'] = params['user']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if 'kind' in params:
            query_params.append(('kind', params['kind']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/{user}/marketplace/data-for-search', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UserAdsDataForSearch',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def modify_item_quantity_on_shopping_cart(self, ad, quantity, **kwargs):  # noqa: E501
        """Modifies the corresponding cart with the new quantity for the given webshop ad.   # noqa: E501

        Modifies the corresponding shopping cart with the new quantity for the  given webshop ad only if it was already added to the cart of the authenticted user and returns the total number of webshop ads in all carts.  For those quantity-limited products the given quantity could have been  adjusted to met the restrictions. You can view the adjustment applied to  each item when retrieving the details of a shopping cart. if you want to  remove the adjustment just send a new request to modify the quantity  and specify the current quantity (i.e the already adjusted and returned  in the details of the shopping cart) as the parameter.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.modify_item_quantity_on_shopping_cart(ad, quantity, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ad: Can be either the advertisement internal identifier or, in case of webshop advertisements, can be the product number (if the owner is the logged user) or a string in the form `productNumber@user`, with the user identifier as well.       (required)
        :param float quantity: The new quantity for the given webshop ad. It could be a decimal  number only if the corresponding webshop ad allows it. If zero then the webshop ad is removed from the cart.  (required)
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.modify_item_quantity_on_shopping_cart_with_http_info(ad, quantity, **kwargs)  # noqa: E501
        else:
            (data) = self.modify_item_quantity_on_shopping_cart_with_http_info(ad, quantity, **kwargs)  # noqa: E501
            return data

    def modify_item_quantity_on_shopping_cart_with_http_info(self, ad, quantity, **kwargs):  # noqa: E501
        """Modifies the corresponding cart with the new quantity for the given webshop ad.   # noqa: E501

        Modifies the corresponding shopping cart with the new quantity for the  given webshop ad only if it was already added to the cart of the authenticted user and returns the total number of webshop ads in all carts.  For those quantity-limited products the given quantity could have been  adjusted to met the restrictions. You can view the adjustment applied to  each item when retrieving the details of a shopping cart. if you want to  remove the adjustment just send a new request to modify the quantity  and specify the current quantity (i.e the already adjusted and returned  in the details of the shopping cart) as the parameter.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.modify_item_quantity_on_shopping_cart_with_http_info(ad, quantity, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ad: Can be either the advertisement internal identifier or, in case of webshop advertisements, can be the product number (if the owner is the logged user) or a string in the form `productNumber@user`, with the user identifier as well.       (required)
        :param float quantity: The new quantity for the given webshop ad. It could be a decimal  number only if the corresponding webshop ad allows it. If zero then the webshop ad is removed from the cart.  (required)
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ad', 'quantity']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method modify_item_quantity_on_shopping_cart" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ad' is set
        if self.api_client.client_side_validation and ('ad' not in params or
                                                       params['ad'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `ad` when calling `modify_item_quantity_on_shopping_cart`")  # noqa: E501
        # verify the required parameter 'quantity' is set
        if self.api_client.client_side_validation and ('quantity' not in params or
                                                       params['quantity'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `quantity` when calling `modify_item_quantity_on_shopping_cart`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ad' in params:
            path_params['ad'] = params['ad']  # noqa: E501

        query_params = []
        if 'quantity' in params:
            query_params.append(('quantity', params['quantity']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['accessClient', 'basic', 'session']  # noqa: E501

        return self.api_client.call_api(
            '/shopping-carts/items/{ad}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='int',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def reject_order(self, order, **kwargs):  # noqa: E501
        """Rejects a pending order.  # noqa: E501

        Rejects a pending order by buyer or seller. The order status must be `pendingBuyer` or  `pendingSeller` to be rejected by the authenticated.  user (buyer/seller).  The possible statuses after an order rejection are: * `rejectedBySeller`: if the authenticated user is  the seller; * `rejectedByBuyer`: if the authenticated user is  the buyer.       # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reject_order(order, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str order: Either the order id or number. If the number is solely comprised of numbers, it must be prefixed by a single quote.  (required)
        :param RejectOrder params: The parameters for rejecting the order.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.reject_order_with_http_info(order, **kwargs)  # noqa: E501
        else:
            (data) = self.reject_order_with_http_info(order, **kwargs)  # noqa: E501
            return data

    def reject_order_with_http_info(self, order, **kwargs):  # noqa: E501
        """Rejects a pending order.  # noqa: E501

        Rejects a pending order by buyer or seller. The order status must be `pendingBuyer` or  `pendingSeller` to be rejected by the authenticated.  user (buyer/seller).  The possible statuses after an order rejection are: * `rejectedBySeller`: if the authenticated user is  the seller; * `rejectedByBuyer`: if the authenticated user is  the buyer.       # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reject_order_with_http_info(order, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str order: Either the order id or number. If the number is solely comprised of numbers, it must be prefixed by a single quote.  (required)
        :param RejectOrder params: The parameters for rejecting the order.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['order', 'params']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method reject_order" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'order' is set
        if self.api_client.client_side_validation and ('order' not in params or
                                                       params['order'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `order` when calling `reject_order`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'order' in params:
            path_params['order'] = params['order']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'params' in params:
            body_params = params['params']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['accessClient', 'basic', 'session']  # noqa: E501

        return self.api_client.call_api(
            '/orders/{order}/reject', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_item_from_shopping_cart(self, ad, **kwargs):  # noqa: E501
        """Removes the given webshop ad from the corresponding shopping cart.  # noqa: E501

        Removes the given webshop ad from the corresponding shopping cart  according to the seller and currency and returns the total number of  the remaining webshop ads in all carts.    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_item_from_shopping_cart(ad, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ad: Can be either the advertisement internal identifier or, in case of webshop advertisements, can be the product number (if the owner is the logged user) or a string in the form `productNumber@user`, with the user identifier as well.       (required)
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remove_item_from_shopping_cart_with_http_info(ad, **kwargs)  # noqa: E501
        else:
            (data) = self.remove_item_from_shopping_cart_with_http_info(ad, **kwargs)  # noqa: E501
            return data

    def remove_item_from_shopping_cart_with_http_info(self, ad, **kwargs):  # noqa: E501
        """Removes the given webshop ad from the corresponding shopping cart.  # noqa: E501

        Removes the given webshop ad from the corresponding shopping cart  according to the seller and currency and returns the total number of  the remaining webshop ads in all carts.    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_item_from_shopping_cart_with_http_info(ad, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ad: Can be either the advertisement internal identifier or, in case of webshop advertisements, can be the product number (if the owner is the logged user) or a string in the form `productNumber@user`, with the user identifier as well.       (required)
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ad']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_item_from_shopping_cart" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ad' is set
        if self.api_client.client_side_validation and ('ad' not in params or
                                                       params['ad'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `ad` when calling `remove_item_from_shopping_cart`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ad' in params:
            path_params['ad'] = params['ad']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['accessClient', 'basic', 'session']  # noqa: E501

        return self.api_client.call_api(
            '/shopping-carts/items/{ad}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='int',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_shopping_cart(self, id, **kwargs):  # noqa: E501
        """Removes a shopping cart.  # noqa: E501

        Removes the given shopping cart by id and returns the total number of  the webshop ads in the remaining all carts.    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_shopping_cart(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The object identification (required)
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remove_shopping_cart_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.remove_shopping_cart_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def remove_shopping_cart_with_http_info(self, id, **kwargs):  # noqa: E501
        """Removes a shopping cart.  # noqa: E501

        Removes the given shopping cart by id and returns the total number of  the webshop ads in the remaining all carts.    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_shopping_cart_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The object identification (required)
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_shopping_cart" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `remove_shopping_cart`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['accessClient', 'basic', 'session']  # noqa: E501

        return self.api_client.call_api(
            '/shopping-carts/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='int',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_ads(self, **kwargs):  # noqa: E501
        """Searches for advertisements.  # noqa: E501

        Returns a page of advertisements that match a given criteria.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_ads(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :param str address_result: Determines which address is returned on the search, if any. By default no addresses are returned. This option is useful for displaying results as locations on a map. In all cases only located addresses (those that have the geographical coordinates set) are returned. When returning all addresses, data related with multiple addresses is returned multiple times. Possible values are: * all: All addresses are returned. * nearest: The nearest address from the reference location is returned. Only usable if a reference coordinate (`latitude` and `longitude`) * none: Addresses are not returned. 
        :param str broker: Either id or an identification, such as login name, e-mail, etc, for the broker of the advertisement owner. The allowed identification methods are those the authenticated user can use on keywords search. 
        :param str category: Either id or internal name of a category 
        :param str currency: Either id or internal name of a currency for the price 
        :param list[str] custom_fields: Advertisement custom field values used as filters. Is a comma-separated array, where each part consists in two parts: the internal name (or custom field id) of the field, and a value, both separated by : (colon).  For example, `customFields=field1:value1,field2:value2`. Sometimes multiple values are accepted. In this case, the multiple values are separated by pipes. For example, customFields=field1:valueA|valueB. Enumerated fields accept multiple values, while numeric and date fields also accept ranges, which are two values, pipe-separated. For example, `customFields=tradeType:offer|search,extraDate:2000-01-01|2001-12-31` would match results whose custom field with internal name `tradeType` is either `offer` or `search`, and whose `extraDate` is between January 1, 2000 and December 31, 2001. To specify a single bound in ranges (like birth dates before December 31, 2001), use a pipe in one of the values, like `customFields=extraDate:|2001-12-31`. A note for dynamic custom fields: If a script is used to generate possible values for search, the list will be returned in the  corresponding data, and it is sent as a pipe-separated list of values (not labels). For example: `customFields=dynamic:a|b|c`. However, it is also possible to perform a keywords-like (full-text) search using the dynamic value label. In this case a single value, prefixed by single quotes should be used. For example: `customFields=dynamic:'business`. 
        :param list[datetime] expiration_period: The minimum / maximum expiration date. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param list[str] groups: Array of either id or internal names of user groups the advertisement owner must belong to 
        :param bool has_images: When set to `true` only advertisements with images are returned 
        :param str keywords: Textual search keywords. Sometimes, like in user search, the fields matched depends on what is configured on the products. 
        :param str kind: The possible kinds of an advertisement Possible values are: * simple: A simple advertisement that can be viewed, but not directly bought * webshop: An advertisement that is part of an webshop. Can be bought, there is stock management, etc. 
        :param float latitude: The reference latitude for distance searches 
        :param float longitude: The reference longitude for distance searches 
        :param float max_distance: Maximum straight-line distance between the informed location and the resulting address. Is measured either in kilometers or miles, depending on the configuration. Only accepted if both `longitude` and `latitude` parameters are passed with the actual reference position. 
        :param str order_by: Indicates how advertisements results are ordered. Possible values are: * date: Newest advertisements are returned first. * distance: Only useful when providing a location, will return nearer advertisements first. * priceAsc: Smaller prices are returned first. Advertisements without price are returned last. * priceDesc: Higher prices are returned first. Advertisements without price are returned last. * random: Without definite order * relevance: This is the default if keywords are used. Best matching advertisements come first. 
        :param str owner: Either id or an identification, such as login name, e-mail, etc, for the advertisement owner. The allowed identification methods are those the authenticated user can use on keywords search. 
        :param int page: The page number (zero-based) of the search. The default value is zero. 
        :param int page_size: The maximum number of records that will be returned on the search. The default value is 40. The maximum number of returned results is configured in Cyclos, and even if more than that is requested, it will be limited by that setting. 
        :param list[BigDecimal] price_range: The minumum / maximum price. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param list[str] profile_fields: User profile fields, both basic (full name, login name, phone, e-mail, etc) and custom fields, that are used for search. Is a comma-separated array, where each part consists in two parts: the internal name (or custom field id) of the field, and a value, both separated by : (colon). For example, `profileFields=field1:value1,field2:value2`. Sometimes multiple values are accepted. In this case, the multiple values are separated by pipes. For example, `profileFields=field1:valueA|valueB`. The accepted fields depend on the products the authenticated user has. Enumerated fields accept multiple values, while numeric and date fields also accept ranges, which are two values, pipe-separated. For example, `profileFields=rank:bronze|silver,birthDate:2000-01-01|2001-12-31` would match results whose custom field with internal name 'rank' is either bronze or silver, and whose 'birthDate' is between January 1, 2000 and December 31, 2001. To specify a single bound in ranges (like birth dates before December 31, 2001), use a pipe in one of the values, like `profileFields=birthDate:|2001-12-31`. The basic profile fields have one of the following identifiers: * `name` or `fullName`: Full name; * `username`, `loginName` or `login`: Login name; * `email`: E-mail; * `phone`: Phone; * `accountNumber`, `account`: Account number; * `image`: Image (accepts a boolean value, indicating that either it   is required that users either have images or not).  If address is an allowed profile field for search, specific address fields may be searched. The allowed ones are normally returned as the `addressFieldsInSearch` field in the corresponding result from a data-for-search request.  The specific address fields are: * `address`: Searches on any address field (not a specific field); * `address.address`: Searches on the fields that represent the   street address, which are `addressLine1`,    `addressLine2`,   `street`,   `buildingNumber` and   `complement`. Note that normally only a   subset of them should be enabled in the configuration (either line   1 / 2 or street + number + complement);  * `address.zip`: Searches for matching zip (postal) code; * `address.poBox`: Searches for matching postal box; * `address.neighborhood`: Searches by neighborhood; * `address.city`: Searches by city; * `address.region`: Searches by region (or state); * `address.country`: Searches by ISO 3166-1 alpha-2 country code.  A note for dynamic custom fields: If a script is used to generate possible values for search, the list will be returned in the  corresponding data, and it is sent as a pipe-separated list of values (not labels). For example: `profileFields=dynamic:a|b|c`. However, it is also possible to perform a keywords-like (full-text) search using the dynamic value label. In this case a single value, prefixed by single quotes should be used. For example: `profileFields=dynamic:'business`. 
        :param list[datetime] publication_period: The minimum / maximum publication date. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param bool return_editable: Whether to return the editable property. Passing `true` will impact the performance a bit, as for each returned advertisement some statuses and permissions need to be checked. 
        :param list[str] statuses: The possible status for an advertisement Possible values for each array element are: * active: The advertisement is published and can be seen by other users. * disabled: The advertisement is disabled because the owner no longer has access to the currency of the advertisement. It cannot be seen by other users. * draft: In draft status, only the owner can see and edit the advertisement. This status is only possible if the system is configured to require authorizations. * expired: The advertisement publication period has already expired, and cannot be seen by other users. * hidden: The advertisement is manually hidden from other users * pending: The advertisement is pending for an authorization and cannot be seen by other users. This status is only possible if the system is configured to require authorizations. * scheduled: The advertisement has a future publication period, and cannot be seen by other users.  
        :return: list[AdResult]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search_ads_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_ads_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_ads_with_http_info(self, **kwargs):  # noqa: E501
        """Searches for advertisements.  # noqa: E501

        Returns a page of advertisements that match a given criteria.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_ads_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :param str address_result: Determines which address is returned on the search, if any. By default no addresses are returned. This option is useful for displaying results as locations on a map. In all cases only located addresses (those that have the geographical coordinates set) are returned. When returning all addresses, data related with multiple addresses is returned multiple times. Possible values are: * all: All addresses are returned. * nearest: The nearest address from the reference location is returned. Only usable if a reference coordinate (`latitude` and `longitude`) * none: Addresses are not returned. 
        :param str broker: Either id or an identification, such as login name, e-mail, etc, for the broker of the advertisement owner. The allowed identification methods are those the authenticated user can use on keywords search. 
        :param str category: Either id or internal name of a category 
        :param str currency: Either id or internal name of a currency for the price 
        :param list[str] custom_fields: Advertisement custom field values used as filters. Is a comma-separated array, where each part consists in two parts: the internal name (or custom field id) of the field, and a value, both separated by : (colon).  For example, `customFields=field1:value1,field2:value2`. Sometimes multiple values are accepted. In this case, the multiple values are separated by pipes. For example, customFields=field1:valueA|valueB. Enumerated fields accept multiple values, while numeric and date fields also accept ranges, which are two values, pipe-separated. For example, `customFields=tradeType:offer|search,extraDate:2000-01-01|2001-12-31` would match results whose custom field with internal name `tradeType` is either `offer` or `search`, and whose `extraDate` is between January 1, 2000 and December 31, 2001. To specify a single bound in ranges (like birth dates before December 31, 2001), use a pipe in one of the values, like `customFields=extraDate:|2001-12-31`. A note for dynamic custom fields: If a script is used to generate possible values for search, the list will be returned in the  corresponding data, and it is sent as a pipe-separated list of values (not labels). For example: `customFields=dynamic:a|b|c`. However, it is also possible to perform a keywords-like (full-text) search using the dynamic value label. In this case a single value, prefixed by single quotes should be used. For example: `customFields=dynamic:'business`. 
        :param list[datetime] expiration_period: The minimum / maximum expiration date. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param list[str] groups: Array of either id or internal names of user groups the advertisement owner must belong to 
        :param bool has_images: When set to `true` only advertisements with images are returned 
        :param str keywords: Textual search keywords. Sometimes, like in user search, the fields matched depends on what is configured on the products. 
        :param str kind: The possible kinds of an advertisement Possible values are: * simple: A simple advertisement that can be viewed, but not directly bought * webshop: An advertisement that is part of an webshop. Can be bought, there is stock management, etc. 
        :param float latitude: The reference latitude for distance searches 
        :param float longitude: The reference longitude for distance searches 
        :param float max_distance: Maximum straight-line distance between the informed location and the resulting address. Is measured either in kilometers or miles, depending on the configuration. Only accepted if both `longitude` and `latitude` parameters are passed with the actual reference position. 
        :param str order_by: Indicates how advertisements results are ordered. Possible values are: * date: Newest advertisements are returned first. * distance: Only useful when providing a location, will return nearer advertisements first. * priceAsc: Smaller prices are returned first. Advertisements without price are returned last. * priceDesc: Higher prices are returned first. Advertisements without price are returned last. * random: Without definite order * relevance: This is the default if keywords are used. Best matching advertisements come first. 
        :param str owner: Either id or an identification, such as login name, e-mail, etc, for the advertisement owner. The allowed identification methods are those the authenticated user can use on keywords search. 
        :param int page: The page number (zero-based) of the search. The default value is zero. 
        :param int page_size: The maximum number of records that will be returned on the search. The default value is 40. The maximum number of returned results is configured in Cyclos, and even if more than that is requested, it will be limited by that setting. 
        :param list[BigDecimal] price_range: The minumum / maximum price. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param list[str] profile_fields: User profile fields, both basic (full name, login name, phone, e-mail, etc) and custom fields, that are used for search. Is a comma-separated array, where each part consists in two parts: the internal name (or custom field id) of the field, and a value, both separated by : (colon). For example, `profileFields=field1:value1,field2:value2`. Sometimes multiple values are accepted. In this case, the multiple values are separated by pipes. For example, `profileFields=field1:valueA|valueB`. The accepted fields depend on the products the authenticated user has. Enumerated fields accept multiple values, while numeric and date fields also accept ranges, which are two values, pipe-separated. For example, `profileFields=rank:bronze|silver,birthDate:2000-01-01|2001-12-31` would match results whose custom field with internal name 'rank' is either bronze or silver, and whose 'birthDate' is between January 1, 2000 and December 31, 2001. To specify a single bound in ranges (like birth dates before December 31, 2001), use a pipe in one of the values, like `profileFields=birthDate:|2001-12-31`. The basic profile fields have one of the following identifiers: * `name` or `fullName`: Full name; * `username`, `loginName` or `login`: Login name; * `email`: E-mail; * `phone`: Phone; * `accountNumber`, `account`: Account number; * `image`: Image (accepts a boolean value, indicating that either it   is required that users either have images or not).  If address is an allowed profile field for search, specific address fields may be searched. The allowed ones are normally returned as the `addressFieldsInSearch` field in the corresponding result from a data-for-search request.  The specific address fields are: * `address`: Searches on any address field (not a specific field); * `address.address`: Searches on the fields that represent the   street address, which are `addressLine1`,    `addressLine2`,   `street`,   `buildingNumber` and   `complement`. Note that normally only a   subset of them should be enabled in the configuration (either line   1 / 2 or street + number + complement);  * `address.zip`: Searches for matching zip (postal) code; * `address.poBox`: Searches for matching postal box; * `address.neighborhood`: Searches by neighborhood; * `address.city`: Searches by city; * `address.region`: Searches by region (or state); * `address.country`: Searches by ISO 3166-1 alpha-2 country code.  A note for dynamic custom fields: If a script is used to generate possible values for search, the list will be returned in the  corresponding data, and it is sent as a pipe-separated list of values (not labels). For example: `profileFields=dynamic:a|b|c`. However, it is also possible to perform a keywords-like (full-text) search using the dynamic value label. In this case a single value, prefixed by single quotes should be used. For example: `profileFields=dynamic:'business`. 
        :param list[datetime] publication_period: The minimum / maximum publication date. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param bool return_editable: Whether to return the editable property. Passing `true` will impact the performance a bit, as for each returned advertisement some statuses and permissions need to be checked. 
        :param list[str] statuses: The possible status for an advertisement Possible values for each array element are: * active: The advertisement is published and can be seen by other users. * disabled: The advertisement is disabled because the owner no longer has access to the currency of the advertisement. It cannot be seen by other users. * draft: In draft status, only the owner can see and edit the advertisement. This status is only possible if the system is configured to require authorizations. * expired: The advertisement publication period has already expired, and cannot be seen by other users. * hidden: The advertisement is manually hidden from other users * pending: The advertisement is pending for an authorization and cannot be seen by other users. This status is only possible if the system is configured to require authorizations. * scheduled: The advertisement has a future publication period, and cannot be seen by other users.  
        :return: list[AdResult]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'address_result', 'broker', 'category', 'currency', 'custom_fields', 'expiration_period', 'groups', 'has_images', 'keywords', 'kind', 'latitude', 'longitude', 'max_distance', 'order_by', 'owner', 'page', 'page_size', 'price_range', 'profile_fields', 'publication_period', 'return_editable', 'statuses']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_ads" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if 'address_result' in params:
            query_params.append(('addressResult', params['address_result']))  # noqa: E501
        if 'broker' in params:
            query_params.append(('broker', params['broker']))  # noqa: E501
        if 'category' in params:
            query_params.append(('category', params['category']))  # noqa: E501
        if 'currency' in params:
            query_params.append(('currency', params['currency']))  # noqa: E501
        if 'custom_fields' in params:
            query_params.append(('customFields', params['custom_fields']))  # noqa: E501
            collection_formats['customFields'] = 'csv'  # noqa: E501
        if 'expiration_period' in params:
            query_params.append(('expirationPeriod', params['expiration_period']))  # noqa: E501
            collection_formats['expirationPeriod'] = 'csv'  # noqa: E501
        if 'groups' in params:
            query_params.append(('groups', params['groups']))  # noqa: E501
            collection_formats['groups'] = 'csv'  # noqa: E501
        if 'has_images' in params:
            query_params.append(('hasImages', params['has_images']))  # noqa: E501
        if 'keywords' in params:
            query_params.append(('keywords', params['keywords']))  # noqa: E501
        if 'kind' in params:
            query_params.append(('kind', params['kind']))  # noqa: E501
        if 'latitude' in params:
            query_params.append(('latitude', params['latitude']))  # noqa: E501
        if 'longitude' in params:
            query_params.append(('longitude', params['longitude']))  # noqa: E501
        if 'max_distance' in params:
            query_params.append(('maxDistance', params['max_distance']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('orderBy', params['order_by']))  # noqa: E501
        if 'owner' in params:
            query_params.append(('owner', params['owner']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'price_range' in params:
            query_params.append(('priceRange', params['price_range']))  # noqa: E501
            collection_formats['priceRange'] = 'csv'  # noqa: E501
        if 'profile_fields' in params:
            query_params.append(('profileFields', params['profile_fields']))  # noqa: E501
            collection_formats['profileFields'] = 'csv'  # noqa: E501
        if 'publication_period' in params:
            query_params.append(('publicationPeriod', params['publication_period']))  # noqa: E501
            collection_formats['publicationPeriod'] = 'csv'  # noqa: E501
        if 'return_editable' in params:
            query_params.append(('returnEditable', params['return_editable']))  # noqa: E501
        if 'statuses' in params:
            query_params.append(('statuses', params['statuses']))  # noqa: E501
            collection_formats['statuses'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/marketplace', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AdResult]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_user_ads(self, user, **kwargs):  # noqa: E501
        """Searches for advertisements of a specific user.  # noqa: E501

        Returns a page of advertisements that match a given criteria for a given  user. Equivallent to calling `GET /marketplace?owner={user}`.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_user_ads(user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: Can be one of: * a user identification value, such as id, username, e-mail, phone, etc.   Id is always allowed, others depend on Cyclos configuration. Note that   a valid numeric value is always considered as id. For example, when   using another identification method that can be numeric only, prefix   the value with a single quote (like in Excel spreadsheets), for   example, `'1234567890`;     * `self` for the currently authenticated user.  (required)
        :param str address_result: Determines which address is returned on the search, if any. By default no addresses are returned. This option is useful for displaying results as locations on a map. In all cases only located addresses (those that have the geographical coordinates set) are returned. When returning all addresses, data related with multiple addresses is returned multiple times. Possible values are: * all: All addresses are returned. * nearest: The nearest address from the reference location is returned. Only usable if a reference coordinate (`latitude` and `longitude`) * none: Addresses are not returned. 
        :param str category: Either id or internal name of a category 
        :param str currency: Either id or internal name of a currency for the price 
        :param list[str] custom_fields: Advertisement custom field values used as filters. Is a comma-separated array, where each part consists in two parts: the internal name (or custom field id) of the field, and a value, both separated by : (colon).  For example, `customFields=field1:value1,field2:value2`. Sometimes multiple values are accepted. In this case, the multiple values are separated by pipes. For example, customFields=field1:valueA|valueB. Enumerated fields accept multiple values, while numeric and date fields also accept ranges, which are two values, pipe-separated. For example, `customFields=tradeType:offer|search,extraDate:2000-01-01|2001-12-31` would match results whose custom field with internal name `tradeType` is either `offer` or `search`, and whose `extraDate` is between January 1, 2000 and December 31, 2001. To specify a single bound in ranges (like birth dates before December 31, 2001), use a pipe in one of the values, like `customFields=extraDate:|2001-12-31`. A note for dynamic custom fields: If a script is used to generate possible values for search, the list will be returned in the  corresponding data, and it is sent as a pipe-separated list of values (not labels). For example: `customFields=dynamic:a|b|c`. However, it is also possible to perform a keywords-like (full-text) search using the dynamic value label. In this case a single value, prefixed by single quotes should be used. For example: `customFields=dynamic:'business`. 
        :param list[datetime] expiration_period: The minimum / maximum expiration date. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param bool has_images: When set to `true` only advertisements with images are returned 
        :param str keywords: Textual search keywords. Sometimes, like in user search, the fields matched depends on what is configured on the products. 
        :param str kind: The possible kinds of an advertisement Possible values are: * simple: A simple advertisement that can be viewed, but not directly bought * webshop: An advertisement that is part of an webshop. Can be bought, there is stock management, etc. 
        :param float latitude: The reference latitude for distance searches 
        :param float longitude: The reference longitude for distance searches 
        :param float max_distance: Maximum straight-line distance between the informed location and the resulting address. Is measured either in kilometers or miles, depending on the configuration. Only accepted if both `longitude` and `latitude` parameters are passed with the actual reference position. 
        :param str order_by: Indicates how advertisements results are ordered. Possible values are: * date: Newest advertisements are returned first. * distance: Only useful when providing a location, will return nearer advertisements first. * priceAsc: Smaller prices are returned first. Advertisements without price are returned last. * priceDesc: Higher prices are returned first. Advertisements without price are returned last. * random: Without definite order * relevance: This is the default if keywords are used. Best matching advertisements come first. 
        :param int page: The page number (zero-based) of the search. The default value is zero. 
        :param int page_size: The maximum number of records that will be returned on the search. The default value is 40. The maximum number of returned results is configured in Cyclos, and even if more than that is requested, it will be limited by that setting. 
        :param list[BigDecimal] price_range: The minumum / maximum price. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param list[str] profile_fields: User profile fields, both basic (full name, login name, phone, e-mail, etc) and custom fields, that are used for search. Is a comma-separated array, where each part consists in two parts: the internal name (or custom field id) of the field, and a value, both separated by : (colon). For example, `profileFields=field1:value1,field2:value2`. Sometimes multiple values are accepted. In this case, the multiple values are separated by pipes. For example, `profileFields=field1:valueA|valueB`. The accepted fields depend on the products the authenticated user has. Enumerated fields accept multiple values, while numeric and date fields also accept ranges, which are two values, pipe-separated. For example, `profileFields=rank:bronze|silver,birthDate:2000-01-01|2001-12-31` would match results whose custom field with internal name 'rank' is either bronze or silver, and whose 'birthDate' is between January 1, 2000 and December 31, 2001. To specify a single bound in ranges (like birth dates before December 31, 2001), use a pipe in one of the values, like `profileFields=birthDate:|2001-12-31`. The basic profile fields have one of the following identifiers: * `name` or `fullName`: Full name; * `username`, `loginName` or `login`: Login name; * `email`: E-mail; * `phone`: Phone; * `accountNumber`, `account`: Account number; * `image`: Image (accepts a boolean value, indicating that either it   is required that users either have images or not).  If address is an allowed profile field for search, specific address fields may be searched. The allowed ones are normally returned as the `addressFieldsInSearch` field in the corresponding result from a data-for-search request.  The specific address fields are: * `address`: Searches on any address field (not a specific field); * `address.address`: Searches on the fields that represent the   street address, which are `addressLine1`,    `addressLine2`,   `street`,   `buildingNumber` and   `complement`. Note that normally only a   subset of them should be enabled in the configuration (either line   1 / 2 or street + number + complement);  * `address.zip`: Searches for matching zip (postal) code; * `address.poBox`: Searches for matching postal box; * `address.neighborhood`: Searches by neighborhood; * `address.city`: Searches by city; * `address.region`: Searches by region (or state); * `address.country`: Searches by ISO 3166-1 alpha-2 country code.  A note for dynamic custom fields: If a script is used to generate possible values for search, the list will be returned in the  corresponding data, and it is sent as a pipe-separated list of values (not labels). For example: `profileFields=dynamic:a|b|c`. However, it is also possible to perform a keywords-like (full-text) search using the dynamic value label. In this case a single value, prefixed by single quotes should be used. For example: `profileFields=dynamic:'business`. 
        :param list[datetime] publication_period: The minimum / maximum publication date. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param list[str] statuses: The possible status for an advertisement Possible values for each array element are: * active: The advertisement is published and can be seen by other users. * disabled: The advertisement is disabled because the owner no longer has access to the currency of the advertisement. It cannot be seen by other users. * draft: In draft status, only the owner can see and edit the advertisement. This status is only possible if the system is configured to require authorizations. * expired: The advertisement publication period has already expired, and cannot be seen by other users. * hidden: The advertisement is manually hidden from other users * pending: The advertisement is pending for an authorization and cannot be seen by other users. This status is only possible if the system is configured to require authorizations. * scheduled: The advertisement has a future publication period, and cannot be seen by other users.  
        :return: list[AdResult]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search_user_ads_with_http_info(user, **kwargs)  # noqa: E501
        else:
            (data) = self.search_user_ads_with_http_info(user, **kwargs)  # noqa: E501
            return data

    def search_user_ads_with_http_info(self, user, **kwargs):  # noqa: E501
        """Searches for advertisements of a specific user.  # noqa: E501

        Returns a page of advertisements that match a given criteria for a given  user. Equivallent to calling `GET /marketplace?owner={user}`.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_user_ads_with_http_info(user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: Can be one of: * a user identification value, such as id, username, e-mail, phone, etc.   Id is always allowed, others depend on Cyclos configuration. Note that   a valid numeric value is always considered as id. For example, when   using another identification method that can be numeric only, prefix   the value with a single quote (like in Excel spreadsheets), for   example, `'1234567890`;     * `self` for the currently authenticated user.  (required)
        :param str address_result: Determines which address is returned on the search, if any. By default no addresses are returned. This option is useful for displaying results as locations on a map. In all cases only located addresses (those that have the geographical coordinates set) are returned. When returning all addresses, data related with multiple addresses is returned multiple times. Possible values are: * all: All addresses are returned. * nearest: The nearest address from the reference location is returned. Only usable if a reference coordinate (`latitude` and `longitude`) * none: Addresses are not returned. 
        :param str category: Either id or internal name of a category 
        :param str currency: Either id or internal name of a currency for the price 
        :param list[str] custom_fields: Advertisement custom field values used as filters. Is a comma-separated array, where each part consists in two parts: the internal name (or custom field id) of the field, and a value, both separated by : (colon).  For example, `customFields=field1:value1,field2:value2`. Sometimes multiple values are accepted. In this case, the multiple values are separated by pipes. For example, customFields=field1:valueA|valueB. Enumerated fields accept multiple values, while numeric and date fields also accept ranges, which are two values, pipe-separated. For example, `customFields=tradeType:offer|search,extraDate:2000-01-01|2001-12-31` would match results whose custom field with internal name `tradeType` is either `offer` or `search`, and whose `extraDate` is between January 1, 2000 and December 31, 2001. To specify a single bound in ranges (like birth dates before December 31, 2001), use a pipe in one of the values, like `customFields=extraDate:|2001-12-31`. A note for dynamic custom fields: If a script is used to generate possible values for search, the list will be returned in the  corresponding data, and it is sent as a pipe-separated list of values (not labels). For example: `customFields=dynamic:a|b|c`. However, it is also possible to perform a keywords-like (full-text) search using the dynamic value label. In this case a single value, prefixed by single quotes should be used. For example: `customFields=dynamic:'business`. 
        :param list[datetime] expiration_period: The minimum / maximum expiration date. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param bool has_images: When set to `true` only advertisements with images are returned 
        :param str keywords: Textual search keywords. Sometimes, like in user search, the fields matched depends on what is configured on the products. 
        :param str kind: The possible kinds of an advertisement Possible values are: * simple: A simple advertisement that can be viewed, but not directly bought * webshop: An advertisement that is part of an webshop. Can be bought, there is stock management, etc. 
        :param float latitude: The reference latitude for distance searches 
        :param float longitude: The reference longitude for distance searches 
        :param float max_distance: Maximum straight-line distance between the informed location and the resulting address. Is measured either in kilometers or miles, depending on the configuration. Only accepted if both `longitude` and `latitude` parameters are passed with the actual reference position. 
        :param str order_by: Indicates how advertisements results are ordered. Possible values are: * date: Newest advertisements are returned first. * distance: Only useful when providing a location, will return nearer advertisements first. * priceAsc: Smaller prices are returned first. Advertisements without price are returned last. * priceDesc: Higher prices are returned first. Advertisements without price are returned last. * random: Without definite order * relevance: This is the default if keywords are used. Best matching advertisements come first. 
        :param int page: The page number (zero-based) of the search. The default value is zero. 
        :param int page_size: The maximum number of records that will be returned on the search. The default value is 40. The maximum number of returned results is configured in Cyclos, and even if more than that is requested, it will be limited by that setting. 
        :param list[BigDecimal] price_range: The minumum / maximum price. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param list[str] profile_fields: User profile fields, both basic (full name, login name, phone, e-mail, etc) and custom fields, that are used for search. Is a comma-separated array, where each part consists in two parts: the internal name (or custom field id) of the field, and a value, both separated by : (colon). For example, `profileFields=field1:value1,field2:value2`. Sometimes multiple values are accepted. In this case, the multiple values are separated by pipes. For example, `profileFields=field1:valueA|valueB`. The accepted fields depend on the products the authenticated user has. Enumerated fields accept multiple values, while numeric and date fields also accept ranges, which are two values, pipe-separated. For example, `profileFields=rank:bronze|silver,birthDate:2000-01-01|2001-12-31` would match results whose custom field with internal name 'rank' is either bronze or silver, and whose 'birthDate' is between January 1, 2000 and December 31, 2001. To specify a single bound in ranges (like birth dates before December 31, 2001), use a pipe in one of the values, like `profileFields=birthDate:|2001-12-31`. The basic profile fields have one of the following identifiers: * `name` or `fullName`: Full name; * `username`, `loginName` or `login`: Login name; * `email`: E-mail; * `phone`: Phone; * `accountNumber`, `account`: Account number; * `image`: Image (accepts a boolean value, indicating that either it   is required that users either have images or not).  If address is an allowed profile field for search, specific address fields may be searched. The allowed ones are normally returned as the `addressFieldsInSearch` field in the corresponding result from a data-for-search request.  The specific address fields are: * `address`: Searches on any address field (not a specific field); * `address.address`: Searches on the fields that represent the   street address, which are `addressLine1`,    `addressLine2`,   `street`,   `buildingNumber` and   `complement`. Note that normally only a   subset of them should be enabled in the configuration (either line   1 / 2 or street + number + complement);  * `address.zip`: Searches for matching zip (postal) code; * `address.poBox`: Searches for matching postal box; * `address.neighborhood`: Searches by neighborhood; * `address.city`: Searches by city; * `address.region`: Searches by region (or state); * `address.country`: Searches by ISO 3166-1 alpha-2 country code.  A note for dynamic custom fields: If a script is used to generate possible values for search, the list will be returned in the  corresponding data, and it is sent as a pipe-separated list of values (not labels). For example: `profileFields=dynamic:a|b|c`. However, it is also possible to perform a keywords-like (full-text) search using the dynamic value label. In this case a single value, prefixed by single quotes should be used. For example: `profileFields=dynamic:'business`. 
        :param list[datetime] publication_period: The minimum / maximum publication date. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param list[str] statuses: The possible status for an advertisement Possible values for each array element are: * active: The advertisement is published and can be seen by other users. * disabled: The advertisement is disabled because the owner no longer has access to the currency of the advertisement. It cannot be seen by other users. * draft: In draft status, only the owner can see and edit the advertisement. This status is only possible if the system is configured to require authorizations. * expired: The advertisement publication period has already expired, and cannot be seen by other users. * hidden: The advertisement is manually hidden from other users * pending: The advertisement is pending for an authorization and cannot be seen by other users. This status is only possible if the system is configured to require authorizations. * scheduled: The advertisement has a future publication period, and cannot be seen by other users.  
        :return: list[AdResult]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user', 'address_result', 'category', 'currency', 'custom_fields', 'expiration_period', 'has_images', 'keywords', 'kind', 'latitude', 'longitude', 'max_distance', 'order_by', 'page', 'page_size', 'price_range', 'profile_fields', 'publication_period', 'statuses']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_user_ads" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user' is set
        if self.api_client.client_side_validation and ('user' not in params or
                                                       params['user'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user` when calling `search_user_ads`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user' in params:
            path_params['user'] = params['user']  # noqa: E501

        query_params = []
        if 'address_result' in params:
            query_params.append(('addressResult', params['address_result']))  # noqa: E501
        if 'category' in params:
            query_params.append(('category', params['category']))  # noqa: E501
        if 'currency' in params:
            query_params.append(('currency', params['currency']))  # noqa: E501
        if 'custom_fields' in params:
            query_params.append(('customFields', params['custom_fields']))  # noqa: E501
            collection_formats['customFields'] = 'csv'  # noqa: E501
        if 'expiration_period' in params:
            query_params.append(('expirationPeriod', params['expiration_period']))  # noqa: E501
            collection_formats['expirationPeriod'] = 'csv'  # noqa: E501
        if 'has_images' in params:
            query_params.append(('hasImages', params['has_images']))  # noqa: E501
        if 'keywords' in params:
            query_params.append(('keywords', params['keywords']))  # noqa: E501
        if 'kind' in params:
            query_params.append(('kind', params['kind']))  # noqa: E501
        if 'latitude' in params:
            query_params.append(('latitude', params['latitude']))  # noqa: E501
        if 'longitude' in params:
            query_params.append(('longitude', params['longitude']))  # noqa: E501
        if 'max_distance' in params:
            query_params.append(('maxDistance', params['max_distance']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('orderBy', params['order_by']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'price_range' in params:
            query_params.append(('priceRange', params['price_range']))  # noqa: E501
            collection_formats['priceRange'] = 'csv'  # noqa: E501
        if 'profile_fields' in params:
            query_params.append(('profileFields', params['profile_fields']))  # noqa: E501
            collection_formats['profileFields'] = 'csv'  # noqa: E501
        if 'publication_period' in params:
            query_params.append(('publicationPeriod', params['publication_period']))  # noqa: E501
            collection_formats['publicationPeriod'] = 'csv'  # noqa: E501
        if 'statuses' in params:
            query_params.append(('statuses', params['statuses']))  # noqa: E501
            collection_formats['statuses'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/{user}/marketplace', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AdResult]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_user_orders(self, user, **kwargs):  # noqa: E501
        """Searches for orders of a specific user.  # noqa: E501

        Returns a page of orders that match a given criteria for a given user.  The authenticated user must be the seller, buyer or a manager user with  permission to view purchases or sales. Note: A list of statuses is accepted but at this moment only one status  can be specified.    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_user_orders(user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: Can be one of: * a user identification value, such as id, username, e-mail, phone, etc.   Id is always allowed, others depend on Cyclos configuration. Note that   a valid numeric value is always considered as id. For example, when   using another identification method that can be numeric only, prefix   the value with a single quote (like in Excel spreadsheets), for   example, `'1234567890`;     * `self` for the currently authenticated user.  (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :param list[datetime] creation_period: The minimum / maximum order creation date. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param str number: The generated order number according to the webshop settings. 
        :param int page: The page number (zero-based) of the search. The default value is zero. 
        :param int page_size: The maximum number of records that will be returned on the search. The default value is 40. The maximum number of returned results is configured in Cyclos, and even if more than that is requested, it will be limited by that setting. 
        :param str related_user: Either id or an identification, such as login name, e-mail, etc, for the seller or buyer according whether we are searching for purchases  or sales. The allowed identification methods are those the authenticated user can use on keywords search.     
        :param bool sales: Are we searching for sales or purchases? If not specified it's assumed purchases (i.e `false`) 
        :param list[str] statuses: The possible statuses for an order Possible values for each array element are: * completed: The order was accepted by the seller and/or buyer and the related payment was done. * disposed: The order was marked as disposed because the seller and/or buyer were removed or they do not have any account in the order's currency. * draft: The order has been created by the seller, but has not yet been sent to the buyer for approval * paymentCanceled: The related payment was not done because was canceled after finish the authorization process. * paymentDenied: The related payment was not done because was denied. * paymentPending: The order was accepted by the seller and/or buyer and the related payment is waiting for authorization. * pendingBuyer: The order is pending by the buyer's action. * pendingSeller: The order is pending by the seller's action. * rejectedByBuyer: The order was rejected by the buyer. * rejectedBySeller: The order was rejected by the seller. 
        :return: list[UserOrderResult]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search_user_orders_with_http_info(user, **kwargs)  # noqa: E501
        else:
            (data) = self.search_user_orders_with_http_info(user, **kwargs)  # noqa: E501
            return data

    def search_user_orders_with_http_info(self, user, **kwargs):  # noqa: E501
        """Searches for orders of a specific user.  # noqa: E501

        Returns a page of orders that match a given criteria for a given user.  The authenticated user must be the seller, buyer or a manager user with  permission to view purchases or sales. Note: A list of statuses is accepted but at this moment only one status  can be specified.    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_user_orders_with_http_info(user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: Can be one of: * a user identification value, such as id, username, e-mail, phone, etc.   Id is always allowed, others depend on Cyclos configuration. Note that   a valid numeric value is always considered as id. For example, when   using another identification method that can be numeric only, prefix   the value with a single quote (like in Excel spreadsheets), for   example, `'1234567890`;     * `self` for the currently authenticated user.  (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :param list[datetime] creation_period: The minimum / maximum order creation date. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param str number: The generated order number according to the webshop settings. 
        :param int page: The page number (zero-based) of the search. The default value is zero. 
        :param int page_size: The maximum number of records that will be returned on the search. The default value is 40. The maximum number of returned results is configured in Cyclos, and even if more than that is requested, it will be limited by that setting. 
        :param str related_user: Either id or an identification, such as login name, e-mail, etc, for the seller or buyer according whether we are searching for purchases  or sales. The allowed identification methods are those the authenticated user can use on keywords search.     
        :param bool sales: Are we searching for sales or purchases? If not specified it's assumed purchases (i.e `false`) 
        :param list[str] statuses: The possible statuses for an order Possible values for each array element are: * completed: The order was accepted by the seller and/or buyer and the related payment was done. * disposed: The order was marked as disposed because the seller and/or buyer were removed or they do not have any account in the order's currency. * draft: The order has been created by the seller, but has not yet been sent to the buyer for approval * paymentCanceled: The related payment was not done because was canceled after finish the authorization process. * paymentDenied: The related payment was not done because was denied. * paymentPending: The order was accepted by the seller and/or buyer and the related payment is waiting for authorization. * pendingBuyer: The order is pending by the buyer's action. * pendingSeller: The order is pending by the seller's action. * rejectedByBuyer: The order was rejected by the buyer. * rejectedBySeller: The order was rejected by the seller. 
        :return: list[UserOrderResult]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user', 'fields', 'creation_period', 'number', 'page', 'page_size', 'related_user', 'sales', 'statuses']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_user_orders" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user' is set
        if self.api_client.client_side_validation and ('user' not in params or
                                                       params['user'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user` when calling `search_user_orders`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user' in params:
            path_params['user'] = params['user']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if 'creation_period' in params:
            query_params.append(('creationPeriod', params['creation_period']))  # noqa: E501
            collection_formats['creationPeriod'] = 'csv'  # noqa: E501
        if 'number' in params:
            query_params.append(('number', params['number']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'related_user' in params:
            query_params.append(('relatedUser', params['related_user']))  # noqa: E501
        if 'sales' in params:
            query_params.append(('sales', params['sales']))  # noqa: E501
        if 'statuses' in params:
            query_params.append(('statuses', params['statuses']))  # noqa: E501
            collection_formats['statuses'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['accessClient', 'basic', 'session']  # noqa: E501

        return self.api_client.call_api(
            '/{user}/orders', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[UserOrderResult]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_delivery_method(self, order, **kwargs):  # noqa: E501
        """Sets delivery method data by seller.  # noqa: E501

        Sets the delivery method data by seller for the order given by id. This operation can be used only if the order is in status  `pendingSeller` and has not already set delivery  method data. After the delivery method has been set the order will be enter in status  `pendingBuyer` to be accepted by buyer.         # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_delivery_method(order, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str order: Either the order id or number. If the number is solely comprised of numbers, it must be prefixed by a single quote.  (required)
        :param SetDeliveryMethod params: The parameters for setting the delivery method.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_delivery_method_with_http_info(order, **kwargs)  # noqa: E501
        else:
            (data) = self.set_delivery_method_with_http_info(order, **kwargs)  # noqa: E501
            return data

    def set_delivery_method_with_http_info(self, order, **kwargs):  # noqa: E501
        """Sets delivery method data by seller.  # noqa: E501

        Sets the delivery method data by seller for the order given by id. This operation can be used only if the order is in status  `pendingSeller` and has not already set delivery  method data. After the delivery method has been set the order will be enter in status  `pendingBuyer` to be accepted by buyer.         # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_delivery_method_with_http_info(order, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str order: Either the order id or number. If the number is solely comprised of numbers, it must be prefixed by a single quote.  (required)
        :param SetDeliveryMethod params: The parameters for setting the delivery method.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['order', 'params']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_delivery_method" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'order' is set
        if self.api_client.client_side_validation and ('order' not in params or
                                                       params['order'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `order` when calling `set_delivery_method`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'order' in params:
            path_params['order'] = params['order']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'params' in params:
            body_params = params['params']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['accessClient', 'basic', 'session']  # noqa: E501

        return self.api_client.call_api(
            '/orders/{order}/seller/set-delivery', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_ad(self, ad, advertisement, **kwargs):  # noqa: E501
        """Updates an existing advertisement.  # noqa: E501

        Updates an existing advertisement.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_ad(ad, advertisement, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ad: Can be either the advertisement internal identifier or, in case of webshop advertisements, can be the product number (if the owner is the logged user) or a string in the form `productNumber@user`, with the user identifier as well.       (required)
        :param AdEdit advertisement: The advertisement to be edited. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_ad_with_http_info(ad, advertisement, **kwargs)  # noqa: E501
        else:
            (data) = self.update_ad_with_http_info(ad, advertisement, **kwargs)  # noqa: E501
            return data

    def update_ad_with_http_info(self, ad, advertisement, **kwargs):  # noqa: E501
        """Updates an existing advertisement.  # noqa: E501

        Updates an existing advertisement.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_ad_with_http_info(ad, advertisement, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ad: Can be either the advertisement internal identifier or, in case of webshop advertisements, can be the product number (if the owner is the logged user) or a string in the form `productNumber@user`, with the user identifier as well.       (required)
        :param AdEdit advertisement: The advertisement to be edited. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ad', 'advertisement']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_ad" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ad' is set
        if self.api_client.client_side_validation and ('ad' not in params or
                                                       params['ad'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `ad` when calling `update_ad`")  # noqa: E501
        # verify the required parameter 'advertisement' is set
        if self.api_client.client_side_validation and ('advertisement' not in params or
                                                       params['advertisement'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `advertisement` when calling `update_ad`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ad' in params:
            path_params['ad'] = params['ad']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'advertisement' in params:
            body_params = params['advertisement']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['accessClient', 'basic', 'session']  # noqa: E501

        return self.api_client.call_api(
            '/marketplace/{ad}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def view_ad(self, ad, **kwargs):  # noqa: E501
        """Returns details of an advertisement.  # noqa: E501

        Returns detailed information of an advertisement.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.view_ad(ad, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ad: Can be either the advertisement internal identifier or, in case of webshop advertisements, can be the product number (if the owner is the logged user) or a string in the form `productNumber@user`, with the user identifier as well.       (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :return: AdView
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.view_ad_with_http_info(ad, **kwargs)  # noqa: E501
        else:
            (data) = self.view_ad_with_http_info(ad, **kwargs)  # noqa: E501
            return data

    def view_ad_with_http_info(self, ad, **kwargs):  # noqa: E501
        """Returns details of an advertisement.  # noqa: E501

        Returns detailed information of an advertisement.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.view_ad_with_http_info(ad, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ad: Can be either the advertisement internal identifier or, in case of webshop advertisements, can be the product number (if the owner is the logged user) or a string in the form `productNumber@user`, with the user identifier as well.       (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :return: AdView
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ad', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method view_ad" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ad' is set
        if self.api_client.client_side_validation and ('ad' not in params or
                                                       params['ad'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `ad` when calling `view_ad`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ad' in params:
            path_params['ad'] = params['ad']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/marketplace/{ad}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AdView',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def view_order(self, order, **kwargs):  # noqa: E501
        """Returns details of an order.  # noqa: E501

        Returns detailed information of an order given by id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.view_order(order, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str order: Either the order id or number. If the number is solely comprised of numbers, it must be prefixed by a single quote.  (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :return: OrderView
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.view_order_with_http_info(order, **kwargs)  # noqa: E501
        else:
            (data) = self.view_order_with_http_info(order, **kwargs)  # noqa: E501
            return data

    def view_order_with_http_info(self, order, **kwargs):  # noqa: E501
        """Returns details of an order.  # noqa: E501

        Returns detailed information of an order given by id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.view_order_with_http_info(order, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str order: Either the order id or number. If the number is solely comprised of numbers, it must be prefixed by a single quote.  (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :return: OrderView
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['order', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method view_order" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'order' is set
        if self.api_client.client_side_validation and ('order' not in params or
                                                       params['order'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `order` when calling `view_order`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'order' in params:
            path_params['order'] = params['order']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['accessClient', 'basic', 'session']  # noqa: E501

        return self.api_client.call_api(
            '/orders/{order}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OrderView',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
