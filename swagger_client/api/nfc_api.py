# coding: utf-8

"""
    Cyclos 4.11.5 API

    The REST API for Cyclos 4.11.5  # noqa: E501

    OpenAPI spec version: 4.11.5
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class NFCApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def cancel_nfc(self, params, **kwargs):  # noqa: E501
        """Cancels a NFC tag  # noqa: E501

        Cancels a NFC token. Must be authenticated as a manager (administrator / broker) of the token owner, and have the correct permission.    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cancel_nfc(params, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NfcTokenParameter params: The parameters for canceling.  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cancel_nfc_with_http_info(params, **kwargs)  # noqa: E501
        else:
            (data) = self.cancel_nfc_with_http_info(params, **kwargs)  # noqa: E501
            return data

    def cancel_nfc_with_http_info(self, params, **kwargs):  # noqa: E501
        """Cancels a NFC tag  # noqa: E501

        Cancels a NFC token. Must be authenticated as a manager (administrator / broker) of the token owner, and have the correct permission.    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cancel_nfc_with_http_info(params, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NfcTokenParameter params: The parameters for canceling.  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['params']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cancel_nfc" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'params' is set
        if self.api_client.client_side_validation and ('params' not in params or
                                                       params['params'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `params` when calling `cancel_nfc`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'params' in params:
            body_params = params['params']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['accessClient', 'basic', 'session']  # noqa: E501

        return self.api_client.call_api(
            '/nfc/cancel', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_nfc_data_for_initialize(self, **kwargs):  # noqa: E501
        """Returns data for NFC tag initialization. Optionally the user can personalize the tag too.  # noqa: E501

        Returns data with the NFC token types the authenticated user can use to initialize NFC tags.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_nfc_data_for_initialize(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :return: NfcDataForInitialize
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_nfc_data_for_initialize_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_nfc_data_for_initialize_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_nfc_data_for_initialize_with_http_info(self, **kwargs):  # noqa: E501
        """Returns data for NFC tag initialization. Optionally the user can personalize the tag too.  # noqa: E501

        Returns data with the NFC token types the authenticated user can use to initialize NFC tags.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_nfc_data_for_initialize_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :return: NfcDataForInitialize
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_nfc_data_for_initialize" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['accessClient', 'basic', 'session']  # noqa: E501

        return self.api_client.call_api(
            '/nfc/data-for-initialize', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NfcDataForInitialize',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_nfc_data_for_personalize(self, token_type, user, **kwargs):  # noqa: E501
        """Returns data for perfornalizing an initialized NFC tag for a user  # noqa: E501

        Returns data for personalizing a NFC tag for a given user.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_nfc_data_for_personalize(token_type, user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token_type: The token type reference (id or internal name) of the token principal type, which is stored on the NFC card being personalized.   (required)
        :param str user: The user reference (id or an identification method) of the user to whom the NFC tag will be personalized. When authenticated as a manager of that user (administrator or broker) no confirmation password will be required for the personalization. However, if the authenticated user is not a manager, the user will be required a confirmation password.  (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :return: NfcDataForPersonalize
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_nfc_data_for_personalize_with_http_info(token_type, user, **kwargs)  # noqa: E501
        else:
            (data) = self.get_nfc_data_for_personalize_with_http_info(token_type, user, **kwargs)  # noqa: E501
            return data

    def get_nfc_data_for_personalize_with_http_info(self, token_type, user, **kwargs):  # noqa: E501
        """Returns data for perfornalizing an initialized NFC tag for a user  # noqa: E501

        Returns data for personalizing a NFC tag for a given user.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_nfc_data_for_personalize_with_http_info(token_type, user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token_type: The token type reference (id or internal name) of the token principal type, which is stored on the NFC card being personalized.   (required)
        :param str user: The user reference (id or an identification method) of the user to whom the NFC tag will be personalized. When authenticated as a manager of that user (administrator or broker) no confirmation password will be required for the personalization. However, if the authenticated user is not a manager, the user will be required a confirmation password.  (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :return: NfcDataForPersonalize
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token_type', 'user', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_nfc_data_for_personalize" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'token_type' is set
        if self.api_client.client_side_validation and ('token_type' not in params or
                                                       params['token_type'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `token_type` when calling `get_nfc_data_for_personalize`")  # noqa: E501
        # verify the required parameter 'user' is set
        if self.api_client.client_side_validation and ('user' not in params or
                                                       params['user'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user` when calling `get_nfc_data_for_personalize`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if 'token_type' in params:
            query_params.append(('tokenType', params['token_type']))  # noqa: E501
        if 'user' in params:
            query_params.append(('user', params['user']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['accessClient', 'basic', 'session']  # noqa: E501

        return self.api_client.call_api(
            '/nfc/data-for-personalize', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NfcDataForPersonalize',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_nfc_token(self, token_type, value, **kwargs):  # noqa: E501
        """Retrieve the NFC token detailed data  # noqa: E501

        Returns the token's data and the user owner of the token (i.e the assigned user, if any)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_nfc_token(token_type, value, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token_type: The internal name or id of the token type (required)
        :param str value: The token value (required)
        :return: TokenDetailed
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_nfc_token_with_http_info(token_type, value, **kwargs)  # noqa: E501
        else:
            (data) = self.get_nfc_token_with_http_info(token_type, value, **kwargs)  # noqa: E501
            return data

    def get_nfc_token_with_http_info(self, token_type, value, **kwargs):  # noqa: E501
        """Retrieve the NFC token detailed data  # noqa: E501

        Returns the token's data and the user owner of the token (i.e the assigned user, if any)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_nfc_token_with_http_info(token_type, value, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token_type: The internal name or id of the token type (required)
        :param str value: The token value (required)
        :return: TokenDetailed
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token_type', 'value']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_nfc_token" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'token_type' is set
        if self.api_client.client_side_validation and ('token_type' not in params or
                                                       params['token_type'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `token_type` when calling `get_nfc_token`")  # noqa: E501
        # verify the required parameter 'value' is set
        if self.api_client.client_side_validation and ('value' not in params or
                                                       params['value'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `value` when calling `get_nfc_token`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'token_type' in params:
            path_params['tokenType'] = params['token_type']  # noqa: E501
        if 'value' in params:
            path_params['value'] = params['value']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['accessClient', 'basic', 'session']  # noqa: E501

        return self.api_client.call_api(
            '/nfc/{tokenType}/{value}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TokenDetailed',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_otp_for_personalize_nfc(self, medium, params, **kwargs):  # noqa: E501
        """Generates a new One-Time-Password (OTP) for a personalizing a NFC tag   # noqa: E501

        Sends a new OTP for the customer which will own the NFC tag. The OTP belongs to the NFC tag owner, not the authenticated user.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_otp_for_personalize_nfc(medium, params, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str medium: The medium the user wants to receive the otp Possible values are: * email: The user will receive an email with the information * sms: The user will receive a sms with the information (only if there is at least one phone enabled for sms)  (required)
        :param NfcPersonalizeOtpParameter params: The parameters identifying the token and the user (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_otp_for_personalize_nfc_with_http_info(medium, params, **kwargs)  # noqa: E501
        else:
            (data) = self.get_otp_for_personalize_nfc_with_http_info(medium, params, **kwargs)  # noqa: E501
            return data

    def get_otp_for_personalize_nfc_with_http_info(self, medium, params, **kwargs):  # noqa: E501
        """Generates a new One-Time-Password (OTP) for a personalizing a NFC tag   # noqa: E501

        Sends a new OTP for the customer which will own the NFC tag. The OTP belongs to the NFC tag owner, not the authenticated user.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_otp_for_personalize_nfc_with_http_info(medium, params, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str medium: The medium the user wants to receive the otp Possible values are: * email: The user will receive an email with the information * sms: The user will receive a sms with the information (only if there is at least one phone enabled for sms)  (required)
        :param NfcPersonalizeOtpParameter params: The parameters identifying the token and the user (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['medium', 'params']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_otp_for_personalize_nfc" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'medium' is set
        if self.api_client.client_side_validation and ('medium' not in params or
                                                       params['medium'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `medium` when calling `get_otp_for_personalize_nfc`")  # noqa: E501
        # verify the required parameter 'params' is set
        if self.api_client.client_side_validation and ('params' not in params or
                                                       params['params'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `params` when calling `get_otp_for_personalize_nfc`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'medium' in params:
            query_params.append(('medium', params['medium']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'params' in params:
            body_params = params['params']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['accessClient', 'basic', 'session']  # noqa: E501

        return self.api_client.call_api(
            '/nfc/personalize/otp', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def initialize_nfc(self, params, **kwargs):  # noqa: E501
        """Initializes a NFC tag  # noqa: E501

        Initializes a NFC tag, creating a new `token` in Cyclos. Returns the keys (PICC Master Key, Application Master Key and the Operational Key) to be stored on the NFC tag.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.initialize_nfc(params, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NfcInitializeParameter params: The parameters for initializing the NFC tag. If the `user` value is left blank, the NFC tag will be only initialized, but not personalized (assigned to any user). If a user is given, the permission to personalize is required (besides the permission to initialize), and is a shortcut to initializing and later personalizing the tag. The initialization is a sensitive operation, as the result contains the plain keys that should be stored on the NFC tag. Hence, can only be performed by managers (with granted permission). Later on, other users (for example, businesses) will be able to personalize the NFC tag for customers.   (required)
        :return: NfcInitializeResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.initialize_nfc_with_http_info(params, **kwargs)  # noqa: E501
        else:
            (data) = self.initialize_nfc_with_http_info(params, **kwargs)  # noqa: E501
            return data

    def initialize_nfc_with_http_info(self, params, **kwargs):  # noqa: E501
        """Initializes a NFC tag  # noqa: E501

        Initializes a NFC tag, creating a new `token` in Cyclos. Returns the keys (PICC Master Key, Application Master Key and the Operational Key) to be stored on the NFC tag.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.initialize_nfc_with_http_info(params, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NfcInitializeParameter params: The parameters for initializing the NFC tag. If the `user` value is left blank, the NFC tag will be only initialized, but not personalized (assigned to any user). If a user is given, the permission to personalize is required (besides the permission to initialize), and is a shortcut to initializing and later personalizing the tag. The initialization is a sensitive operation, as the result contains the plain keys that should be stored on the NFC tag. Hence, can only be performed by managers (with granted permission). Later on, other users (for example, businesses) will be able to personalize the NFC tag for customers.   (required)
        :return: NfcInitializeResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['params']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method initialize_nfc" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'params' is set
        if self.api_client.client_side_validation and ('params' not in params or
                                                       params['params'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `params` when calling `initialize_nfc`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'params' in params:
            body_params = params['params']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['accessClient', 'basic', 'session']  # noqa: E501

        return self.api_client.call_api(
            '/nfc/initialize', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NfcInitializeResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def nfc_external_auth(self, params, **kwargs):  # noqa: E501
        """NFC external authentication  # noqa: E501

        The NFC tag will normally perform a mutual authentication, by first generating a challenge that must be encrypted by the external system with the device key. With this the external system is authenticated. Cyclos also returns a challenge that should be encrypted by the NFC tag. This challenge can later be passed in specific operations (for example, when performing a payment) for Cyclos to make sure the NFC tag is present on the operation.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.nfc_external_auth(params, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NfcExternalAuthenticateParameter params: The parameters for the external authentication. If the `token` value is informed, it will be performed an external authentication with the token itself, using the Application Master Key (AMK). If the `token` is not informed, the authentication will be done using the PICC Master Key (PMK), which is useful, for example, when initializing the NFC tag.   (required)
        :return: NfcExternalAuthenticateResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.nfc_external_auth_with_http_info(params, **kwargs)  # noqa: E501
        else:
            (data) = self.nfc_external_auth_with_http_info(params, **kwargs)  # noqa: E501
            return data

    def nfc_external_auth_with_http_info(self, params, **kwargs):  # noqa: E501
        """NFC external authentication  # noqa: E501

        The NFC tag will normally perform a mutual authentication, by first generating a challenge that must be encrypted by the external system with the device key. With this the external system is authenticated. Cyclos also returns a challenge that should be encrypted by the NFC tag. This challenge can later be passed in specific operations (for example, when performing a payment) for Cyclos to make sure the NFC tag is present on the operation.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.nfc_external_auth_with_http_info(params, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NfcExternalAuthenticateParameter params: The parameters for the external authentication. If the `token` value is informed, it will be performed an external authentication with the token itself, using the Application Master Key (AMK). If the `token` is not informed, the authentication will be done using the PICC Master Key (PMK), which is useful, for example, when initializing the NFC tag.   (required)
        :return: NfcExternalAuthenticateResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['params']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method nfc_external_auth" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'params' is set
        if self.api_client.client_side_validation and ('params' not in params or
                                                       params['params'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `params` when calling `nfc_external_auth`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'params' in params:
            body_params = params['params']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['accessClient', 'basic', 'session']  # noqa: E501

        return self.api_client.call_api(
            '/nfc/external-auth', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NfcExternalAuthenticateResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def personalize_nfc(self, params, **kwargs):  # noqa: E501
        """Personalizes a NFC tag  # noqa: E501

        Personalization requires a NFC tag that was previously initialized, but is still unassigned. This operation doesn't store any key in the NFC tag itself, hence the plain keys are not returned. What is needed is an external authentication with the NFC tag, in order to ensure the card is physically present. The flow for personalizing a tag is: - `GET /nfc/data-for-personalize?user={user}`: Obtain the data for   personalizing NFC tags for this user. The most important information   is which the confirmation password will be required, if any; - `POST /nfc/external-auth`: With a challenge previously encrypted by the   NFC tag, invoke this operation. If the challenge matches the NFC token   in Cyclos, it will be encrypted and returned. Also a new challenge will   be returned, which should be then encrypted by the NFC tag for later   being sent back; - `POST /nfc/personalize`: With the encrypted challenge and the   confirmation password (if any), this operation will update the NFC   token in Cyclos, so it is now assigned to the specified user. From   this point on, the NFC tag is operational.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.personalize_nfc(params, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NfcPersonalizeParameter params: The parameters for the initialization.  (required)
        :param str confirmation_password: The password used to confirm this action, if needed. The actual password type, if any, depends on the Cyclos configuration for the current channel. 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.personalize_nfc_with_http_info(params, **kwargs)  # noqa: E501
        else:
            (data) = self.personalize_nfc_with_http_info(params, **kwargs)  # noqa: E501
            return data

    def personalize_nfc_with_http_info(self, params, **kwargs):  # noqa: E501
        """Personalizes a NFC tag  # noqa: E501

        Personalization requires a NFC tag that was previously initialized, but is still unassigned. This operation doesn't store any key in the NFC tag itself, hence the plain keys are not returned. What is needed is an external authentication with the NFC tag, in order to ensure the card is physically present. The flow for personalizing a tag is: - `GET /nfc/data-for-personalize?user={user}`: Obtain the data for   personalizing NFC tags for this user. The most important information   is which the confirmation password will be required, if any; - `POST /nfc/external-auth`: With a challenge previously encrypted by the   NFC tag, invoke this operation. If the challenge matches the NFC token   in Cyclos, it will be encrypted and returned. Also a new challenge will   be returned, which should be then encrypted by the NFC tag for later   being sent back; - `POST /nfc/personalize`: With the encrypted challenge and the   confirmation password (if any), this operation will update the NFC   token in Cyclos, so it is now assigned to the specified user. From   this point on, the NFC tag is operational.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.personalize_nfc_with_http_info(params, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NfcPersonalizeParameter params: The parameters for the initialization.  (required)
        :param str confirmation_password: The password used to confirm this action, if needed. The actual password type, if any, depends on the Cyclos configuration for the current channel. 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['params', 'confirmation_password']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method personalize_nfc" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'params' is set
        if self.api_client.client_side_validation and ('params' not in params or
                                                       params['params'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `params` when calling `personalize_nfc`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'confirmation_password' in params:
            header_params['confirmationPassword'] = params['confirmation_password']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'params' in params:
            body_params = params['params']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['accessClient', 'basic', 'session']  # noqa: E501

        return self.api_client.call_api(
            '/nfc/personalize', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
