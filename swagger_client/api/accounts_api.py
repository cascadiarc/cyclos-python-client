# coding: utf-8

"""
    Cyclos 4.11.5 API

    The REST API for Cyclos 4.11.5  # noqa: E501

    OpenAPI spec version: 4.11.5
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class AccountsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def get_account_balance_history(self, owner, account_type, **kwargs):  # noqa: E501
        """Returns the account balances over time  # noqa: E501

        Receives a period and an interval, returning the balance over each corresponding date. The maximum number of data points is 60, so it is possible to get the balances per day over 2 months. For larger periods, use weeks or months. When no period is given, assumes the beginning of current year or the account creation date, whichever is newer. When no interval is given, one is assumed. Also returns status of the given account   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_balance_history(owner, account_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str owner: Can be one of: * a user identification value, such as id, username, e-mail, phone, etc.   Id is always allowed, others depend on Cyclos configuration. Note that   a valid numeric value is always considered as id. For example, when   using another identification method that can be numeric only, prefix   the value with a single quote (like in Excel spreadsheets), for   example, `'1234567890`;     * `self` for the currently authenticated user; * `system` for data that belongs to the system.  (required)
        :param str account_type: The account type (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :param list[datetime] date_period: The minimum / maximum transfer date. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param str interval_unit: The time unit for the data point interval Possible values are: * days: Day(s) * hours: Hour(s) * millis: Millisecond(s) * minutes: Minute(s) * months: Month(s) * seconds: Second(s) * weeks: Week(s) * years: Year(s) 
        :param int interval_count: A data point every X units. For example, it is possible to request the balance every 3 days. Defaults to 1. 
        :return: AccountBalanceHistoryResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_account_balance_history_with_http_info(owner, account_type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_account_balance_history_with_http_info(owner, account_type, **kwargs)  # noqa: E501
            return data

    def get_account_balance_history_with_http_info(self, owner, account_type, **kwargs):  # noqa: E501
        """Returns the account balances over time  # noqa: E501

        Receives a period and an interval, returning the balance over each corresponding date. The maximum number of data points is 60, so it is possible to get the balances per day over 2 months. For larger periods, use weeks or months. When no period is given, assumes the beginning of current year or the account creation date, whichever is newer. When no interval is given, one is assumed. Also returns status of the given account   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_balance_history_with_http_info(owner, account_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str owner: Can be one of: * a user identification value, such as id, username, e-mail, phone, etc.   Id is always allowed, others depend on Cyclos configuration. Note that   a valid numeric value is always considered as id. For example, when   using another identification method that can be numeric only, prefix   the value with a single quote (like in Excel spreadsheets), for   example, `'1234567890`;     * `self` for the currently authenticated user; * `system` for data that belongs to the system.  (required)
        :param str account_type: The account type (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :param list[datetime] date_period: The minimum / maximum transfer date. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param str interval_unit: The time unit for the data point interval Possible values are: * days: Day(s) * hours: Hour(s) * millis: Millisecond(s) * minutes: Minute(s) * months: Month(s) * seconds: Second(s) * weeks: Week(s) * years: Year(s) 
        :param int interval_count: A data point every X units. For example, it is possible to request the balance every 3 days. Defaults to 1. 
        :return: AccountBalanceHistoryResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['owner', 'account_type', 'fields', 'date_period', 'interval_unit', 'interval_count']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_account_balance_history" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and ('owner' not in params or
                                                       params['owner'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `owner` when calling `get_account_balance_history`")  # noqa: E501
        # verify the required parameter 'account_type' is set
        if self.api_client.client_side_validation and ('account_type' not in params or
                                                       params['account_type'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `account_type` when calling `get_account_balance_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in params:
            path_params['owner'] = params['owner']  # noqa: E501
        if 'account_type' in params:
            path_params['accountType'] = params['account_type']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if 'date_period' in params:
            query_params.append(('datePeriod', params['date_period']))  # noqa: E501
            collection_formats['datePeriod'] = 'csv'  # noqa: E501
        if 'interval_unit' in params:
            query_params.append(('intervalUnit', params['interval_unit']))  # noqa: E501
        if 'interval_count' in params:
            query_params.append(('intervalCount', params['interval_count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['accessClient', 'basic', 'session']  # noqa: E501

        return self.api_client.call_api(
            '/{owner}/accounts/{accountType}/balances-history', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AccountBalanceHistoryResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_account_history_data_by_owner_and_type(self, owner, account_type, **kwargs):  # noqa: E501
        """Returns data for searching an account history by owner and type  # noqa: E501

        Returns configuration data for searching entries in a specific account history, as well as status information for that account information.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_history_data_by_owner_and_type(owner, account_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str owner: Can be one of: * a user identification value, such as id, username, e-mail, phone, etc.   Id is always allowed, others depend on Cyclos configuration. Note that   a valid numeric value is always considered as id. For example, when   using another identification method that can be numeric only, prefix   the value with a single quote (like in Excel spreadsheets), for   example, `'1234567890`;     * `self` for the currently authenticated user; * `system` for data that belongs to the system.  (required)
        :param str account_type: The internal name or id of the account type (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :return: DataForAccountHistory
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_account_history_data_by_owner_and_type_with_http_info(owner, account_type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_account_history_data_by_owner_and_type_with_http_info(owner, account_type, **kwargs)  # noqa: E501
            return data

    def get_account_history_data_by_owner_and_type_with_http_info(self, owner, account_type, **kwargs):  # noqa: E501
        """Returns data for searching an account history by owner and type  # noqa: E501

        Returns configuration data for searching entries in a specific account history, as well as status information for that account information.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_history_data_by_owner_and_type_with_http_info(owner, account_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str owner: Can be one of: * a user identification value, such as id, username, e-mail, phone, etc.   Id is always allowed, others depend on Cyclos configuration. Note that   a valid numeric value is always considered as id. For example, when   using another identification method that can be numeric only, prefix   the value with a single quote (like in Excel spreadsheets), for   example, `'1234567890`;     * `self` for the currently authenticated user; * `system` for data that belongs to the system.  (required)
        :param str account_type: The internal name or id of the account type (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :return: DataForAccountHistory
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['owner', 'account_type', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_account_history_data_by_owner_and_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and ('owner' not in params or
                                                       params['owner'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `owner` when calling `get_account_history_data_by_owner_and_type`")  # noqa: E501
        # verify the required parameter 'account_type' is set
        if self.api_client.client_side_validation and ('account_type' not in params or
                                                       params['account_type'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `account_type` when calling `get_account_history_data_by_owner_and_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in params:
            path_params['owner'] = params['owner']  # noqa: E501
        if 'account_type' in params:
            path_params['accountType'] = params['account_type']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['accessClient', 'basic', 'session']  # noqa: E501

        return self.api_client.call_api(
            '/{owner}/accounts/{accountType}/data-for-history', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DataForAccountHistory',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_account_status_by_owner_and_type(self, owner, account_type, **kwargs):  # noqa: E501
        """Returns the status of an account by owner and type  # noqa: E501

        Returns the account status for a specific account. The account type may be either the identifier or internal name. The status will contain both instant status information, that is, the same fields as `AccountStatus`, plus status that depend on the input parameters, such as those defined in `AccountWithHistoryStatus`. The actual data inside the result depend on the configuration, in the `Account status indicators` option, which is used to limit the amount of data returned.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_status_by_owner_and_type(owner, account_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str owner: Can be one of: * a user identification value, such as id, username, e-mail, phone, etc.   Id is always allowed, others depend on Cyclos configuration. Note that   a valid numeric value is always considered as id. For example, when   using another identification method that can be numeric only, prefix   the value with a single quote (like in Excel spreadsheets), for   example, `'1234567890`;     * `self` for the currently authenticated user; * `system` for data that belongs to the system.  (required)
        :param str account_type: The account type (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :param list[str] access_clients: References to access clients (id or token) used to perform / receive the  transfer. 
        :param list[BigDecimal] amount_range: The minimum / maximum amount. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param str broker: Reference to the broker of users involved in transfers. Is only taken into account if authenticated as administrator. 
        :param str by: Reference to the user that was authenticated when the transfer was performed. Is only taken into account if authenticated as administrator. 
        :param list[str] channels: Reference to the channel used to perform / receive the transfer. Only taken into account if authenticated as administrator. 
        :param bool charged_back: When set to either `true` will only return transfers that were charged-back. When set to `false`, will only return transfers that were not charged-back. When left blank will not filter by this creterion. 
        :param list[str] custom_fields: Transaction custom field values used as filters. Is a comma-separated array, where each part consists in two parts: the internal name (or custom field id) of the field, and a value, both separated by : (colon).  For example, `customFields=field1:value1,field2:value2`. Sometimes multiple values are accepted. In this case, the multiple values are separated by pipes. For example, customFields=field1:valueA|valueB. Enumerated fields accept multiple values, while numeric and date fields also accept ranges, which are two values, pipe-separated. For example, `customFields=rank:bronze|silver,documentDate:2000-01-01|2001-12-31` would match results whose custom field with internal name `rank` is either `bronze` or `silver`, and whose `documentDate` is between January 1, 2000 and December 31, 2001. To specify a single bound in ranges (like birth dates before December 31, 2001), use a pipe in one of the values, like `customFields=documentDate:|2001-12-31`. A note for dynamic custom fields: If a script is used to generate possible values for search, the list will be returned in the  corresponding data, and it is sent as a pipe-separated list of values (not labels). For example: `customFields=dynamic:a|b|c`. However, it is also possible to perform a partial-match search using the dynamic value label. In this case a single value, prefixed or enclosed by single quotes should be used. For example: `customFields=dynamic:'business` or `customFields=dynamic:'business'`.        
        :param list[datetime] date_period: The minimum / maximum transfer date. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param str direction: Indicates whether from an account POV a transfer is a credit or debit Possible values are: * credit: The transfer impacts the balance positively * debit: The transfer impacts the balance negatively 
        :param list[str] excluded_ids: List of transfers ids to be excluded from the result. 
        :param bool from_current_access_client: Flag indicating whether to include only transfers by the current access client. 
        :param list[str] groups: Reference to the user group used to perform / receive the transfer. Only taken into account if authenticated as administrator. 
        :param bool include_generated_by_access_client: Flag indicating whether to include or not the generated transfer. Only valid if there is at least one access client specified. For example if a `ticket` or `paymentRequest` was processed then a new transfer will be generated. 
        :param int page: The page number (zero-based) of the search. The default value is zero. 
        :param int page_size: The maximum number of records that will be returned on the search. The default value is 40. The maximum number of returned results is configured in Cyclos, and even if more than that is requested, it will be limited by that setting. 
        :param list[str] statuses: Transfer statuses used as search criteria. Each array element should be either the identifier or the status qualified internal name, composed by flow internal name, a dot, and the status internal name. For example, `loan.open` would be a valid internal name. 
        :param str transaction_number: The transaction number of the matching transfer 
        :param list[str] transfer_filters: Reference to the transfer filters, which filters transfers by type. May be either the internal id or qualified transfer filter internal name, in the format `accountType.transferFilter`. 
        :param list[str] transfer_kinds: Indicates the reason the transfer was created Possible values for each array element are: * accountFee: A transfer generated by an account fee charge * chargeback: A transfer which is a chargeback of another transfer * import: An imported transfer * initialCredit: A transfer which is the initial credit for a newly created account * payment: A transfer generated by a direct payment or accepting a webshop order * recurringPayment: A transfer generated when processing a recurring payment * scheduledPaymentInstallment: A transfer generated when processing a scheduled payment installment * transferFee: A transfer generated by a transfer fee charge 
        :param list[str] transfer_types: Reference to the transfer types for filter. May be either the internal id or qualified transfer type internal name, in the format `accountType.transferType`. 
        :param str user: Reference a user that should have either received / performed the transfer. 
        :return: AccountWithHistoryStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_account_status_by_owner_and_type_with_http_info(owner, account_type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_account_status_by_owner_and_type_with_http_info(owner, account_type, **kwargs)  # noqa: E501
            return data

    def get_account_status_by_owner_and_type_with_http_info(self, owner, account_type, **kwargs):  # noqa: E501
        """Returns the status of an account by owner and type  # noqa: E501

        Returns the account status for a specific account. The account type may be either the identifier or internal name. The status will contain both instant status information, that is, the same fields as `AccountStatus`, plus status that depend on the input parameters, such as those defined in `AccountWithHistoryStatus`. The actual data inside the result depend on the configuration, in the `Account status indicators` option, which is used to limit the amount of data returned.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_status_by_owner_and_type_with_http_info(owner, account_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str owner: Can be one of: * a user identification value, such as id, username, e-mail, phone, etc.   Id is always allowed, others depend on Cyclos configuration. Note that   a valid numeric value is always considered as id. For example, when   using another identification method that can be numeric only, prefix   the value with a single quote (like in Excel spreadsheets), for   example, `'1234567890`;     * `self` for the currently authenticated user; * `system` for data that belongs to the system.  (required)
        :param str account_type: The account type (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :param list[str] access_clients: References to access clients (id or token) used to perform / receive the  transfer. 
        :param list[BigDecimal] amount_range: The minimum / maximum amount. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param str broker: Reference to the broker of users involved in transfers. Is only taken into account if authenticated as administrator. 
        :param str by: Reference to the user that was authenticated when the transfer was performed. Is only taken into account if authenticated as administrator. 
        :param list[str] channels: Reference to the channel used to perform / receive the transfer. Only taken into account if authenticated as administrator. 
        :param bool charged_back: When set to either `true` will only return transfers that were charged-back. When set to `false`, will only return transfers that were not charged-back. When left blank will not filter by this creterion. 
        :param list[str] custom_fields: Transaction custom field values used as filters. Is a comma-separated array, where each part consists in two parts: the internal name (or custom field id) of the field, and a value, both separated by : (colon).  For example, `customFields=field1:value1,field2:value2`. Sometimes multiple values are accepted. In this case, the multiple values are separated by pipes. For example, customFields=field1:valueA|valueB. Enumerated fields accept multiple values, while numeric and date fields also accept ranges, which are two values, pipe-separated. For example, `customFields=rank:bronze|silver,documentDate:2000-01-01|2001-12-31` would match results whose custom field with internal name `rank` is either `bronze` or `silver`, and whose `documentDate` is between January 1, 2000 and December 31, 2001. To specify a single bound in ranges (like birth dates before December 31, 2001), use a pipe in one of the values, like `customFields=documentDate:|2001-12-31`. A note for dynamic custom fields: If a script is used to generate possible values for search, the list will be returned in the  corresponding data, and it is sent as a pipe-separated list of values (not labels). For example: `customFields=dynamic:a|b|c`. However, it is also possible to perform a partial-match search using the dynamic value label. In this case a single value, prefixed or enclosed by single quotes should be used. For example: `customFields=dynamic:'business` or `customFields=dynamic:'business'`.        
        :param list[datetime] date_period: The minimum / maximum transfer date. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param str direction: Indicates whether from an account POV a transfer is a credit or debit Possible values are: * credit: The transfer impacts the balance positively * debit: The transfer impacts the balance negatively 
        :param list[str] excluded_ids: List of transfers ids to be excluded from the result. 
        :param bool from_current_access_client: Flag indicating whether to include only transfers by the current access client. 
        :param list[str] groups: Reference to the user group used to perform / receive the transfer. Only taken into account if authenticated as administrator. 
        :param bool include_generated_by_access_client: Flag indicating whether to include or not the generated transfer. Only valid if there is at least one access client specified. For example if a `ticket` or `paymentRequest` was processed then a new transfer will be generated. 
        :param int page: The page number (zero-based) of the search. The default value is zero. 
        :param int page_size: The maximum number of records that will be returned on the search. The default value is 40. The maximum number of returned results is configured in Cyclos, and even if more than that is requested, it will be limited by that setting. 
        :param list[str] statuses: Transfer statuses used as search criteria. Each array element should be either the identifier or the status qualified internal name, composed by flow internal name, a dot, and the status internal name. For example, `loan.open` would be a valid internal name. 
        :param str transaction_number: The transaction number of the matching transfer 
        :param list[str] transfer_filters: Reference to the transfer filters, which filters transfers by type. May be either the internal id or qualified transfer filter internal name, in the format `accountType.transferFilter`. 
        :param list[str] transfer_kinds: Indicates the reason the transfer was created Possible values for each array element are: * accountFee: A transfer generated by an account fee charge * chargeback: A transfer which is a chargeback of another transfer * import: An imported transfer * initialCredit: A transfer which is the initial credit for a newly created account * payment: A transfer generated by a direct payment or accepting a webshop order * recurringPayment: A transfer generated when processing a recurring payment * scheduledPaymentInstallment: A transfer generated when processing a scheduled payment installment * transferFee: A transfer generated by a transfer fee charge 
        :param list[str] transfer_types: Reference to the transfer types for filter. May be either the internal id or qualified transfer type internal name, in the format `accountType.transferType`. 
        :param str user: Reference a user that should have either received / performed the transfer. 
        :return: AccountWithHistoryStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['owner', 'account_type', 'fields', 'access_clients', 'amount_range', 'broker', 'by', 'channels', 'charged_back', 'custom_fields', 'date_period', 'direction', 'excluded_ids', 'from_current_access_client', 'groups', 'include_generated_by_access_client', 'page', 'page_size', 'statuses', 'transaction_number', 'transfer_filters', 'transfer_kinds', 'transfer_types', 'user']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_account_status_by_owner_and_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and ('owner' not in params or
                                                       params['owner'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `owner` when calling `get_account_status_by_owner_and_type`")  # noqa: E501
        # verify the required parameter 'account_type' is set
        if self.api_client.client_side_validation and ('account_type' not in params or
                                                       params['account_type'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `account_type` when calling `get_account_status_by_owner_and_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in params:
            path_params['owner'] = params['owner']  # noqa: E501
        if 'account_type' in params:
            path_params['accountType'] = params['account_type']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if 'access_clients' in params:
            query_params.append(('accessClients', params['access_clients']))  # noqa: E501
            collection_formats['accessClients'] = 'csv'  # noqa: E501
        if 'amount_range' in params:
            query_params.append(('amountRange', params['amount_range']))  # noqa: E501
            collection_formats['amountRange'] = 'csv'  # noqa: E501
        if 'broker' in params:
            query_params.append(('broker', params['broker']))  # noqa: E501
        if 'by' in params:
            query_params.append(('by', params['by']))  # noqa: E501
        if 'channels' in params:
            query_params.append(('channels', params['channels']))  # noqa: E501
            collection_formats['channels'] = 'csv'  # noqa: E501
        if 'charged_back' in params:
            query_params.append(('chargedBack', params['charged_back']))  # noqa: E501
        if 'custom_fields' in params:
            query_params.append(('customFields', params['custom_fields']))  # noqa: E501
            collection_formats['customFields'] = 'csv'  # noqa: E501
        if 'date_period' in params:
            query_params.append(('datePeriod', params['date_period']))  # noqa: E501
            collection_formats['datePeriod'] = 'csv'  # noqa: E501
        if 'direction' in params:
            query_params.append(('direction', params['direction']))  # noqa: E501
        if 'excluded_ids' in params:
            query_params.append(('excludedIds', params['excluded_ids']))  # noqa: E501
            collection_formats['excludedIds'] = 'csv'  # noqa: E501
        if 'from_current_access_client' in params:
            query_params.append(('fromCurrentAccessClient', params['from_current_access_client']))  # noqa: E501
        if 'groups' in params:
            query_params.append(('groups', params['groups']))  # noqa: E501
            collection_formats['groups'] = 'csv'  # noqa: E501
        if 'include_generated_by_access_client' in params:
            query_params.append(('includeGeneratedByAccessClient', params['include_generated_by_access_client']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'statuses' in params:
            query_params.append(('statuses', params['statuses']))  # noqa: E501
            collection_formats['statuses'] = 'csv'  # noqa: E501
        if 'transaction_number' in params:
            query_params.append(('transactionNumber', params['transaction_number']))  # noqa: E501
        if 'transfer_filters' in params:
            query_params.append(('transferFilters', params['transfer_filters']))  # noqa: E501
            collection_formats['transferFilters'] = 'csv'  # noqa: E501
        if 'transfer_kinds' in params:
            query_params.append(('transferKinds', params['transfer_kinds']))  # noqa: E501
            collection_formats['transferKinds'] = 'csv'  # noqa: E501
        if 'transfer_types' in params:
            query_params.append(('transferTypes', params['transfer_types']))  # noqa: E501
            collection_formats['transferTypes'] = 'csv'  # noqa: E501
        if 'user' in params:
            query_params.append(('user', params['user']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['accessClient', 'basic', 'session']  # noqa: E501

        return self.api_client.call_api(
            '/{owner}/accounts/{accountType}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AccountWithHistoryStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_user_balances_data(self, **kwargs):  # noqa: E501
        """Returns data for searching users together with their balances  # noqa: E501

        Returns configuration data for searching users together with their balances. The account types are returned, and the account type needs to be passed in the other `user-balances` operations.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_balances_data(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :return: DataForUserBalancesSearch
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_user_balances_data_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_user_balances_data_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_user_balances_data_with_http_info(self, **kwargs):  # noqa: E501
        """Returns data for searching users together with their balances  # noqa: E501

        Returns configuration data for searching users together with their balances. The account types are returned, and the account type needs to be passed in the other `user-balances` operations.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_balances_data_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :return: DataForUserBalancesSearch
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user_balances_data" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['accessClient', 'basic', 'session']  # noqa: E501

        return self.api_client.call_api(
            '/accounts/data-for-user-balances', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DataForUserBalancesSearch',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_user_balances_summary(self, account_type, **kwargs):  # noqa: E501
        """Returns summarized information for the user balances search  # noqa: E501

        Returns summaries for each balance level (if ranges are defined in either account type or filter), as well as the total summary.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_balances_summary(account_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_type: The account type  (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :param list[datetime] activation_period: The minimum / maximum user activation date. Only taken into account if searching as administrator or managing broker. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param str address_result: Determines which address is returned on the search, if any. By default no addresses are returned. This option is useful for displaying results as locations on a map. In all cases only located addresses (those that have the geographical coordinates set) are returned. When returning all addresses, data related with multiple addresses is returned multiple times. Possible values are: * all: All addresses are returned. * nearest: The nearest address from the reference location is returned. Only usable if a reference coordinate (`latitude` and `longitude`) * none: Addresses are not returned. * primary: The primary (default) user address is returned 
        :param list[int] balance_range: The minimum and / or maximum balance for users to be returned. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param list[str] brokers: Either id or a principal (login name, e-mail, etc) for brokers 
        :param list[datetime] creation_period: The minimum / maximum user creation date. Only taken into account if searching as administrator or managing broker. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param list[str] groups: Either id or internal names of groups / group sets 
        :param bool include_group: When set to `true` and the logged user has permission to view user groups, will return the `group` property on users.  
        :param bool include_group_set: When set to `true` and the logged user has permission to view user group sets, will return the `groupSet` property on users.  
        :param str keywords: Textual search keywords. Sometimes, like in user search, the fields matched depends on what is configured on the products. 
        :param list[datetime] last_incoming_transfer_period: The minimum / maximum date of the last incoming transfer for users to be returned. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param list[datetime] last_login_period: The minimum / maximum user last login date. Only taken into account if searching as administrator or managing broker. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param list[datetime] last_outgoing_transfer_period: The minimum / maximum date of the last outgoing transfer for users to be returned. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param float latitude: The reference latitude for distance searches 
        :param float longitude: The reference longitude for distance searches 
        :param bool main_broker_only: When set to `true`, will match only users that have the brokers as set in the `brokers` parameter as main broker.  
        :param float max_distance: Maximum straight-line distance between the informed location and the resulting address. Is measured either in kilometers or miles, depending on the configuration. Only accepted if both `longitude` and `latitude` parameters are passed with the actual reference position. 
        :param list[int] medium_balance_range: An array with 2 elements, describing the lower and upper medium balance bounds. If not specified, the range defined in the account type will be used. If that one is also not defined, there will be no definitions for balance levels. Both bounds need to be set as 2 element in the array, or it won't be considered. 
        :param list[datetime] negative_since_period: The minimum / maximum negative-since date for users to be returned. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param int page: The page number (zero-based) of the search. The default value is zero. 
        :param int page_size: The maximum number of records that will be returned on the search. The default value is 40. The maximum number of returned results is configured in Cyclos, and even if more than that is requested, it will be limited by that setting. 
        :param list[str] profile_fields: User profile fields, both basic (full name, login name, phone, e-mail, etc) and custom fields, that are used for search. Is a comma-separated array, where each part consists in two parts: the internal name (or custom field id) of the field, and a value, both separated by : (colon). For example, `profileFields=field1:value1,field2:value2`. Sometimes multiple values are accepted. In this case, the multiple values are separated by pipes. For example, `profileFields=field1:valueA|valueB`. The accepted fields depend on the products the authenticated user has. Enumerated fields accept multiple values, while numeric and date fields also accept ranges, which are two values, pipe-separated. For example, `profileFields=rank:bronze|silver,birthDate:2000-01-01|2001-12-31` would match results whose custom field with internal name 'rank' is either bronze or silver, and whose 'birthDate' is between January 1, 2000 and December 31, 2001. To specify a single bound in ranges (like birth dates before December 31, 2001), use a pipe in one of the values, like `profileFields=birthDate:|2001-12-31`. The basic profile fields have one of the following identifiers: * `name` or `fullName`: Full name; * `username`, `loginName` or `login`: Login name; * `email`: E-mail; * `phone`: Phone; * `accountNumber`, `account`: Account number; * `image`: Image (accepts a boolean value, indicating that either it   is required that users either have images or not).  If address is an allowed profile field for search, specific address fields may be searched. The allowed ones are normally returned as the `addressFieldsInSearch` field in the corresponding result from a data-for-search request.  The specific address fields are: * `address`: Searches on any address field (not a specific field); * `address.address`: Searches on the fields that represent the   street address, which are `addressLine1`,    `addressLine2`,   `street`,   `buildingNumber` and   `complement`. Note that normally only a   subset of them should be enabled in the configuration (either line   1 / 2 or street + number + complement);  * `address.zip`: Searches for matching zip (postal) code; * `address.poBox`: Searches for matching postal box; * `address.neighborhood`: Searches by neighborhood; * `address.city`: Searches by city; * `address.region`: Searches by region (or state); * `address.country`: Searches by ISO 3166-1 alpha-2 country code.  A note for dynamic custom fields: If a script is used to generate possible values for search, the list will be returned in the  corresponding data, and it is sent as a pipe-separated list of values (not labels). For example: `profileFields=dynamic:a|b|c`. However, it is also possible to perform a keywords-like (full-text) search using the dynamic value label. In this case a single value, prefixed by single quotes should be used. For example: `profileFields=dynamic:'business`. 
        :param list[str] users_to_exclude: Indicated the users to be excluded from the result 
        :param list[str] users_to_include: Indicated the users to be included in the result.  Any other user not present in this list will be excluded from the result. 
        :return: UsersWithBalanceSummary
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_user_balances_summary_with_http_info(account_type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_user_balances_summary_with_http_info(account_type, **kwargs)  # noqa: E501
            return data

    def get_user_balances_summary_with_http_info(self, account_type, **kwargs):  # noqa: E501
        """Returns summarized information for the user balances search  # noqa: E501

        Returns summaries for each balance level (if ranges are defined in either account type or filter), as well as the total summary.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_balances_summary_with_http_info(account_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_type: The account type  (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :param list[datetime] activation_period: The minimum / maximum user activation date. Only taken into account if searching as administrator or managing broker. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param str address_result: Determines which address is returned on the search, if any. By default no addresses are returned. This option is useful for displaying results as locations on a map. In all cases only located addresses (those that have the geographical coordinates set) are returned. When returning all addresses, data related with multiple addresses is returned multiple times. Possible values are: * all: All addresses are returned. * nearest: The nearest address from the reference location is returned. Only usable if a reference coordinate (`latitude` and `longitude`) * none: Addresses are not returned. * primary: The primary (default) user address is returned 
        :param list[int] balance_range: The minimum and / or maximum balance for users to be returned. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param list[str] brokers: Either id or a principal (login name, e-mail, etc) for brokers 
        :param list[datetime] creation_period: The minimum / maximum user creation date. Only taken into account if searching as administrator or managing broker. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param list[str] groups: Either id or internal names of groups / group sets 
        :param bool include_group: When set to `true` and the logged user has permission to view user groups, will return the `group` property on users.  
        :param bool include_group_set: When set to `true` and the logged user has permission to view user group sets, will return the `groupSet` property on users.  
        :param str keywords: Textual search keywords. Sometimes, like in user search, the fields matched depends on what is configured on the products. 
        :param list[datetime] last_incoming_transfer_period: The minimum / maximum date of the last incoming transfer for users to be returned. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param list[datetime] last_login_period: The minimum / maximum user last login date. Only taken into account if searching as administrator or managing broker. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param list[datetime] last_outgoing_transfer_period: The minimum / maximum date of the last outgoing transfer for users to be returned. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param float latitude: The reference latitude for distance searches 
        :param float longitude: The reference longitude for distance searches 
        :param bool main_broker_only: When set to `true`, will match only users that have the brokers as set in the `brokers` parameter as main broker.  
        :param float max_distance: Maximum straight-line distance between the informed location and the resulting address. Is measured either in kilometers or miles, depending on the configuration. Only accepted if both `longitude` and `latitude` parameters are passed with the actual reference position. 
        :param list[int] medium_balance_range: An array with 2 elements, describing the lower and upper medium balance bounds. If not specified, the range defined in the account type will be used. If that one is also not defined, there will be no definitions for balance levels. Both bounds need to be set as 2 element in the array, or it won't be considered. 
        :param list[datetime] negative_since_period: The minimum / maximum negative-since date for users to be returned. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param int page: The page number (zero-based) of the search. The default value is zero. 
        :param int page_size: The maximum number of records that will be returned on the search. The default value is 40. The maximum number of returned results is configured in Cyclos, and even if more than that is requested, it will be limited by that setting. 
        :param list[str] profile_fields: User profile fields, both basic (full name, login name, phone, e-mail, etc) and custom fields, that are used for search. Is a comma-separated array, where each part consists in two parts: the internal name (or custom field id) of the field, and a value, both separated by : (colon). For example, `profileFields=field1:value1,field2:value2`. Sometimes multiple values are accepted. In this case, the multiple values are separated by pipes. For example, `profileFields=field1:valueA|valueB`. The accepted fields depend on the products the authenticated user has. Enumerated fields accept multiple values, while numeric and date fields also accept ranges, which are two values, pipe-separated. For example, `profileFields=rank:bronze|silver,birthDate:2000-01-01|2001-12-31` would match results whose custom field with internal name 'rank' is either bronze or silver, and whose 'birthDate' is between January 1, 2000 and December 31, 2001. To specify a single bound in ranges (like birth dates before December 31, 2001), use a pipe in one of the values, like `profileFields=birthDate:|2001-12-31`. The basic profile fields have one of the following identifiers: * `name` or `fullName`: Full name; * `username`, `loginName` or `login`: Login name; * `email`: E-mail; * `phone`: Phone; * `accountNumber`, `account`: Account number; * `image`: Image (accepts a boolean value, indicating that either it   is required that users either have images or not).  If address is an allowed profile field for search, specific address fields may be searched. The allowed ones are normally returned as the `addressFieldsInSearch` field in the corresponding result from a data-for-search request.  The specific address fields are: * `address`: Searches on any address field (not a specific field); * `address.address`: Searches on the fields that represent the   street address, which are `addressLine1`,    `addressLine2`,   `street`,   `buildingNumber` and   `complement`. Note that normally only a   subset of them should be enabled in the configuration (either line   1 / 2 or street + number + complement);  * `address.zip`: Searches for matching zip (postal) code; * `address.poBox`: Searches for matching postal box; * `address.neighborhood`: Searches by neighborhood; * `address.city`: Searches by city; * `address.region`: Searches by region (or state); * `address.country`: Searches by ISO 3166-1 alpha-2 country code.  A note for dynamic custom fields: If a script is used to generate possible values for search, the list will be returned in the  corresponding data, and it is sent as a pipe-separated list of values (not labels). For example: `profileFields=dynamic:a|b|c`. However, it is also possible to perform a keywords-like (full-text) search using the dynamic value label. In this case a single value, prefixed by single quotes should be used. For example: `profileFields=dynamic:'business`. 
        :param list[str] users_to_exclude: Indicated the users to be excluded from the result 
        :param list[str] users_to_include: Indicated the users to be included in the result.  Any other user not present in this list will be excluded from the result. 
        :return: UsersWithBalanceSummary
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_type', 'fields', 'activation_period', 'address_result', 'balance_range', 'brokers', 'creation_period', 'groups', 'include_group', 'include_group_set', 'keywords', 'last_incoming_transfer_period', 'last_login_period', 'last_outgoing_transfer_period', 'latitude', 'longitude', 'main_broker_only', 'max_distance', 'medium_balance_range', 'negative_since_period', 'page', 'page_size', 'profile_fields', 'users_to_exclude', 'users_to_include']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user_balances_summary" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_type' is set
        if self.api_client.client_side_validation and ('account_type' not in params or
                                                       params['account_type'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `account_type` when calling `get_user_balances_summary`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_type' in params:
            path_params['accountType'] = params['account_type']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if 'activation_period' in params:
            query_params.append(('activationPeriod', params['activation_period']))  # noqa: E501
            collection_formats['activationPeriod'] = 'csv'  # noqa: E501
        if 'address_result' in params:
            query_params.append(('addressResult', params['address_result']))  # noqa: E501
        if 'balance_range' in params:
            query_params.append(('balanceRange', params['balance_range']))  # noqa: E501
            collection_formats['balanceRange'] = 'csv'  # noqa: E501
        if 'brokers' in params:
            query_params.append(('brokers', params['brokers']))  # noqa: E501
            collection_formats['brokers'] = 'csv'  # noqa: E501
        if 'creation_period' in params:
            query_params.append(('creationPeriod', params['creation_period']))  # noqa: E501
            collection_formats['creationPeriod'] = 'csv'  # noqa: E501
        if 'groups' in params:
            query_params.append(('groups', params['groups']))  # noqa: E501
            collection_formats['groups'] = 'csv'  # noqa: E501
        if 'include_group' in params:
            query_params.append(('includeGroup', params['include_group']))  # noqa: E501
        if 'include_group_set' in params:
            query_params.append(('includeGroupSet', params['include_group_set']))  # noqa: E501
        if 'keywords' in params:
            query_params.append(('keywords', params['keywords']))  # noqa: E501
        if 'last_incoming_transfer_period' in params:
            query_params.append(('lastIncomingTransferPeriod', params['last_incoming_transfer_period']))  # noqa: E501
            collection_formats['lastIncomingTransferPeriod'] = 'csv'  # noqa: E501
        if 'last_login_period' in params:
            query_params.append(('lastLoginPeriod', params['last_login_period']))  # noqa: E501
            collection_formats['lastLoginPeriod'] = 'csv'  # noqa: E501
        if 'last_outgoing_transfer_period' in params:
            query_params.append(('lastOutgoingTransferPeriod', params['last_outgoing_transfer_period']))  # noqa: E501
            collection_formats['lastOutgoingTransferPeriod'] = 'csv'  # noqa: E501
        if 'latitude' in params:
            query_params.append(('latitude', params['latitude']))  # noqa: E501
        if 'longitude' in params:
            query_params.append(('longitude', params['longitude']))  # noqa: E501
        if 'main_broker_only' in params:
            query_params.append(('mainBrokerOnly', params['main_broker_only']))  # noqa: E501
        if 'max_distance' in params:
            query_params.append(('maxDistance', params['max_distance']))  # noqa: E501
        if 'medium_balance_range' in params:
            query_params.append(('mediumBalanceRange', params['medium_balance_range']))  # noqa: E501
            collection_formats['mediumBalanceRange'] = 'csv'  # noqa: E501
        if 'negative_since_period' in params:
            query_params.append(('negativeSincePeriod', params['negative_since_period']))  # noqa: E501
            collection_formats['negativeSincePeriod'] = 'csv'  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'profile_fields' in params:
            query_params.append(('profileFields', params['profile_fields']))  # noqa: E501
            collection_formats['profileFields'] = 'csv'  # noqa: E501
        if 'users_to_exclude' in params:
            query_params.append(('usersToExclude', params['users_to_exclude']))  # noqa: E501
            collection_formats['usersToExclude'] = 'csv'  # noqa: E501
        if 'users_to_include' in params:
            query_params.append(('usersToInclude', params['users_to_include']))  # noqa: E501
            collection_formats['usersToInclude'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['accessClient', 'basic', 'session']  # noqa: E501

        return self.api_client.call_api(
            '/accounts/{accountType}/user-balances/summary', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UsersWithBalanceSummary',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_accounts_by_owner(self, owner, **kwargs):  # noqa: E501
        """Lists accounts of the given owner with their statuses  # noqa: E501

        Lists all visible accounts of the given user, or system accounts if the owner 'system' is used. Each account has status information, like the current balance, avaliable balance and so on. However, the returned data depend on the configuration, in the `Account status indicators` option, which is used to limit the amount of data returned.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_accounts_by_owner(owner, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str owner: Can be one of: * a user identification value, such as id, username, e-mail, phone, etc.   Id is always allowed, others depend on Cyclos configuration. Note that   a valid numeric value is always considered as id. For example, when   using another identification method that can be numeric only, prefix   the value with a single quote (like in Excel spreadsheets), for   example, `'1234567890`;     * `self` for the currently authenticated user; * `system` for data that belongs to the system.  (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :return: list[AccountWithStatus]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_accounts_by_owner_with_http_info(owner, **kwargs)  # noqa: E501
        else:
            (data) = self.list_accounts_by_owner_with_http_info(owner, **kwargs)  # noqa: E501
            return data

    def list_accounts_by_owner_with_http_info(self, owner, **kwargs):  # noqa: E501
        """Lists accounts of the given owner with their statuses  # noqa: E501

        Lists all visible accounts of the given user, or system accounts if the owner 'system' is used. Each account has status information, like the current balance, avaliable balance and so on. However, the returned data depend on the configuration, in the `Account status indicators` option, which is used to limit the amount of data returned.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_accounts_by_owner_with_http_info(owner, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str owner: Can be one of: * a user identification value, such as id, username, e-mail, phone, etc.   Id is always allowed, others depend on Cyclos configuration. Note that   a valid numeric value is always considered as id. For example, when   using another identification method that can be numeric only, prefix   the value with a single quote (like in Excel spreadsheets), for   example, `'1234567890`;     * `self` for the currently authenticated user; * `system` for data that belongs to the system.  (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :return: list[AccountWithStatus]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['owner', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_accounts_by_owner" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and ('owner' not in params or
                                                       params['owner'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `owner` when calling `list_accounts_by_owner`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in params:
            path_params['owner'] = params['owner']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['accessClient', 'basic', 'session']  # noqa: E501

        return self.api_client.call_api(
            '/{owner}/accounts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AccountWithStatus]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_account_history(self, owner, account_type, **kwargs):  # noqa: E501
        """Search an account history  # noqa: E501

        Returns a page of account history entries for a specific account, according to the given criteria   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_account_history(owner, account_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str owner: Can be one of: * a user identification value, such as id, username, e-mail, phone, etc.   Id is always allowed, others depend on Cyclos configuration. Note that   a valid numeric value is always considered as id. For example, when   using another identification method that can be numeric only, prefix   the value with a single quote (like in Excel spreadsheets), for   example, `'1234567890`;     * `self` for the currently authenticated user; * `system` for data that belongs to the system.  (required)
        :param str account_type: The account type (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :param list[str] access_clients: References to access clients (id or token) used to perform / receive the  transfer. 
        :param list[BigDecimal] amount_range: The minimum / maximum amount. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param str broker: Reference to the broker of users involved in transfers. Is only taken into account if authenticated as administrator. 
        :param str by: Reference to the user that was authenticated when the transfer was performed. Is only taken into account if authenticated as administrator. 
        :param list[str] channels: Reference to the channel used to perform / receive the transfer. Only taken into account if authenticated as administrator. 
        :param bool charged_back: When set to either `true` will only return transfers that were charged-back. When set to `false`, will only return transfers that were not charged-back. When left blank will not filter by this creterion. 
        :param list[str] custom_fields: Transaction custom field values used as filters. Is a comma-separated array, where each part consists in two parts: the internal name (or custom field id) of the field, and a value, both separated by : (colon).  For example, `customFields=field1:value1,field2:value2`. Sometimes multiple values are accepted. In this case, the multiple values are separated by pipes. For example, customFields=field1:valueA|valueB. Enumerated fields accept multiple values, while numeric and date fields also accept ranges, which are two values, pipe-separated. For example, `customFields=rank:bronze|silver,documentDate:2000-01-01|2001-12-31` would match results whose custom field with internal name `rank` is either `bronze` or `silver`, and whose `documentDate` is between January 1, 2000 and December 31, 2001. To specify a single bound in ranges (like birth dates before December 31, 2001), use a pipe in one of the values, like `customFields=documentDate:|2001-12-31`. A note for dynamic custom fields: If a script is used to generate possible values for search, the list will be returned in the  corresponding data, and it is sent as a pipe-separated list of values (not labels). For example: `customFields=dynamic:a|b|c`. However, it is also possible to perform a partial-match search using the dynamic value label. In this case a single value, prefixed or enclosed by single quotes should be used. For example: `customFields=dynamic:'business` or `customFields=dynamic:'business'`.        
        :param list[datetime] date_period: The minimum / maximum transfer date. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param str direction: Indicates whether from an account POV a transfer is a credit or debit Possible values are: * credit: The transfer impacts the balance positively * debit: The transfer impacts the balance negatively 
        :param list[str] excluded_ids: List of transfers ids to be excluded from the result. 
        :param bool from_current_access_client: Flag indicating whether to include only transfers by the current access client. 
        :param list[str] groups: Reference to the user group used to perform / receive the transfer. Only taken into account if authenticated as administrator. 
        :param bool include_generated_by_access_client: Flag indicating whether to include or not the generated transfer. Only valid if there is at least one access client specified. For example if a `ticket` or `paymentRequest` was processed then a new transfer will be generated. 
        :param str order_by: Contains the possible 'order by' values when searching for transfers  Possible values are: * amountAsc: The result is ordered by amount descendant * amountDesc: The result is ordered by amount descendant * dateAsc: The result is ordered by date ascendant * dateDesc: The result is ordered by date descendant 
        :param int page: The page number (zero-based) of the search. The default value is zero. 
        :param int page_size: The maximum number of records that will be returned on the search. The default value is 40. The maximum number of returned results is configured in Cyclos, and even if more than that is requested, it will be limited by that setting. 
        :param list[str] statuses: Transfer statuses used as search criteria. Each array element should be either the identifier or the status qualified internal name, composed by flow internal name, a dot, and the status internal name. For example, `loan.open` would be a valid internal name. 
        :param str transaction_number: The transaction number of the matching transfer 
        :param list[str] transfer_filters: Reference to the transfer filters, which filters transfers by type. May be either the internal id or qualified transfer filter internal name, in the format `accountType.transferFilter`. 
        :param list[str] transfer_kinds: Indicates the reason the transfer was created Possible values for each array element are: * accountFee: A transfer generated by an account fee charge * chargeback: A transfer which is a chargeback of another transfer * import: An imported transfer * initialCredit: A transfer which is the initial credit for a newly created account * payment: A transfer generated by a direct payment or accepting a webshop order * recurringPayment: A transfer generated when processing a recurring payment * scheduledPaymentInstallment: A transfer generated when processing a scheduled payment installment * transferFee: A transfer generated by a transfer fee charge 
        :param list[str] transfer_types: Reference to the transfer types for filter. May be either the internal id or qualified transfer type internal name, in the format `accountType.transferType`. 
        :param str user: Reference a user that should have either received / performed the transfer. 
        :return: list[AccountHistoryResult]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search_account_history_with_http_info(owner, account_type, **kwargs)  # noqa: E501
        else:
            (data) = self.search_account_history_with_http_info(owner, account_type, **kwargs)  # noqa: E501
            return data

    def search_account_history_with_http_info(self, owner, account_type, **kwargs):  # noqa: E501
        """Search an account history  # noqa: E501

        Returns a page of account history entries for a specific account, according to the given criteria   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_account_history_with_http_info(owner, account_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str owner: Can be one of: * a user identification value, such as id, username, e-mail, phone, etc.   Id is always allowed, others depend on Cyclos configuration. Note that   a valid numeric value is always considered as id. For example, when   using another identification method that can be numeric only, prefix   the value with a single quote (like in Excel spreadsheets), for   example, `'1234567890`;     * `self` for the currently authenticated user; * `system` for data that belongs to the system.  (required)
        :param str account_type: The account type (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :param list[str] access_clients: References to access clients (id or token) used to perform / receive the  transfer. 
        :param list[BigDecimal] amount_range: The minimum / maximum amount. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param str broker: Reference to the broker of users involved in transfers. Is only taken into account if authenticated as administrator. 
        :param str by: Reference to the user that was authenticated when the transfer was performed. Is only taken into account if authenticated as administrator. 
        :param list[str] channels: Reference to the channel used to perform / receive the transfer. Only taken into account if authenticated as administrator. 
        :param bool charged_back: When set to either `true` will only return transfers that were charged-back. When set to `false`, will only return transfers that were not charged-back. When left blank will not filter by this creterion. 
        :param list[str] custom_fields: Transaction custom field values used as filters. Is a comma-separated array, where each part consists in two parts: the internal name (or custom field id) of the field, and a value, both separated by : (colon).  For example, `customFields=field1:value1,field2:value2`. Sometimes multiple values are accepted. In this case, the multiple values are separated by pipes. For example, customFields=field1:valueA|valueB. Enumerated fields accept multiple values, while numeric and date fields also accept ranges, which are two values, pipe-separated. For example, `customFields=rank:bronze|silver,documentDate:2000-01-01|2001-12-31` would match results whose custom field with internal name `rank` is either `bronze` or `silver`, and whose `documentDate` is between January 1, 2000 and December 31, 2001. To specify a single bound in ranges (like birth dates before December 31, 2001), use a pipe in one of the values, like `customFields=documentDate:|2001-12-31`. A note for dynamic custom fields: If a script is used to generate possible values for search, the list will be returned in the  corresponding data, and it is sent as a pipe-separated list of values (not labels). For example: `customFields=dynamic:a|b|c`. However, it is also possible to perform a partial-match search using the dynamic value label. In this case a single value, prefixed or enclosed by single quotes should be used. For example: `customFields=dynamic:'business` or `customFields=dynamic:'business'`.        
        :param list[datetime] date_period: The minimum / maximum transfer date. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param str direction: Indicates whether from an account POV a transfer is a credit or debit Possible values are: * credit: The transfer impacts the balance positively * debit: The transfer impacts the balance negatively 
        :param list[str] excluded_ids: List of transfers ids to be excluded from the result. 
        :param bool from_current_access_client: Flag indicating whether to include only transfers by the current access client. 
        :param list[str] groups: Reference to the user group used to perform / receive the transfer. Only taken into account if authenticated as administrator. 
        :param bool include_generated_by_access_client: Flag indicating whether to include or not the generated transfer. Only valid if there is at least one access client specified. For example if a `ticket` or `paymentRequest` was processed then a new transfer will be generated. 
        :param str order_by: Contains the possible 'order by' values when searching for transfers  Possible values are: * amountAsc: The result is ordered by amount descendant * amountDesc: The result is ordered by amount descendant * dateAsc: The result is ordered by date ascendant * dateDesc: The result is ordered by date descendant 
        :param int page: The page number (zero-based) of the search. The default value is zero. 
        :param int page_size: The maximum number of records that will be returned on the search. The default value is 40. The maximum number of returned results is configured in Cyclos, and even if more than that is requested, it will be limited by that setting. 
        :param list[str] statuses: Transfer statuses used as search criteria. Each array element should be either the identifier or the status qualified internal name, composed by flow internal name, a dot, and the status internal name. For example, `loan.open` would be a valid internal name. 
        :param str transaction_number: The transaction number of the matching transfer 
        :param list[str] transfer_filters: Reference to the transfer filters, which filters transfers by type. May be either the internal id or qualified transfer filter internal name, in the format `accountType.transferFilter`. 
        :param list[str] transfer_kinds: Indicates the reason the transfer was created Possible values for each array element are: * accountFee: A transfer generated by an account fee charge * chargeback: A transfer which is a chargeback of another transfer * import: An imported transfer * initialCredit: A transfer which is the initial credit for a newly created account * payment: A transfer generated by a direct payment or accepting a webshop order * recurringPayment: A transfer generated when processing a recurring payment * scheduledPaymentInstallment: A transfer generated when processing a scheduled payment installment * transferFee: A transfer generated by a transfer fee charge 
        :param list[str] transfer_types: Reference to the transfer types for filter. May be either the internal id or qualified transfer type internal name, in the format `accountType.transferType`. 
        :param str user: Reference a user that should have either received / performed the transfer. 
        :return: list[AccountHistoryResult]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['owner', 'account_type', 'fields', 'access_clients', 'amount_range', 'broker', 'by', 'channels', 'charged_back', 'custom_fields', 'date_period', 'direction', 'excluded_ids', 'from_current_access_client', 'groups', 'include_generated_by_access_client', 'order_by', 'page', 'page_size', 'statuses', 'transaction_number', 'transfer_filters', 'transfer_kinds', 'transfer_types', 'user']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_account_history" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'owner' is set
        if self.api_client.client_side_validation and ('owner' not in params or
                                                       params['owner'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `owner` when calling `search_account_history`")  # noqa: E501
        # verify the required parameter 'account_type' is set
        if self.api_client.client_side_validation and ('account_type' not in params or
                                                       params['account_type'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `account_type` when calling `search_account_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner' in params:
            path_params['owner'] = params['owner']  # noqa: E501
        if 'account_type' in params:
            path_params['accountType'] = params['account_type']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if 'access_clients' in params:
            query_params.append(('accessClients', params['access_clients']))  # noqa: E501
            collection_formats['accessClients'] = 'csv'  # noqa: E501
        if 'amount_range' in params:
            query_params.append(('amountRange', params['amount_range']))  # noqa: E501
            collection_formats['amountRange'] = 'csv'  # noqa: E501
        if 'broker' in params:
            query_params.append(('broker', params['broker']))  # noqa: E501
        if 'by' in params:
            query_params.append(('by', params['by']))  # noqa: E501
        if 'channels' in params:
            query_params.append(('channels', params['channels']))  # noqa: E501
            collection_formats['channels'] = 'csv'  # noqa: E501
        if 'charged_back' in params:
            query_params.append(('chargedBack', params['charged_back']))  # noqa: E501
        if 'custom_fields' in params:
            query_params.append(('customFields', params['custom_fields']))  # noqa: E501
            collection_formats['customFields'] = 'csv'  # noqa: E501
        if 'date_period' in params:
            query_params.append(('datePeriod', params['date_period']))  # noqa: E501
            collection_formats['datePeriod'] = 'csv'  # noqa: E501
        if 'direction' in params:
            query_params.append(('direction', params['direction']))  # noqa: E501
        if 'excluded_ids' in params:
            query_params.append(('excludedIds', params['excluded_ids']))  # noqa: E501
            collection_formats['excludedIds'] = 'csv'  # noqa: E501
        if 'from_current_access_client' in params:
            query_params.append(('fromCurrentAccessClient', params['from_current_access_client']))  # noqa: E501
        if 'groups' in params:
            query_params.append(('groups', params['groups']))  # noqa: E501
            collection_formats['groups'] = 'csv'  # noqa: E501
        if 'include_generated_by_access_client' in params:
            query_params.append(('includeGeneratedByAccessClient', params['include_generated_by_access_client']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('orderBy', params['order_by']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'statuses' in params:
            query_params.append(('statuses', params['statuses']))  # noqa: E501
            collection_formats['statuses'] = 'csv'  # noqa: E501
        if 'transaction_number' in params:
            query_params.append(('transactionNumber', params['transaction_number']))  # noqa: E501
        if 'transfer_filters' in params:
            query_params.append(('transferFilters', params['transfer_filters']))  # noqa: E501
            collection_formats['transferFilters'] = 'csv'  # noqa: E501
        if 'transfer_kinds' in params:
            query_params.append(('transferKinds', params['transfer_kinds']))  # noqa: E501
            collection_formats['transferKinds'] = 'csv'  # noqa: E501
        if 'transfer_types' in params:
            query_params.append(('transferTypes', params['transfer_types']))  # noqa: E501
            collection_formats['transferTypes'] = 'csv'  # noqa: E501
        if 'user' in params:
            query_params.append(('user', params['user']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['accessClient', 'basic', 'session']  # noqa: E501

        return self.api_client.call_api(
            '/{owner}/accounts/{accountType}/history', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AccountHistoryResult]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_users_with_balances(self, account_type, **kwargs):  # noqa: E501
        """Searches for users together with balance information  # noqa: E501

        Returns the users, together with their balances   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_users_with_balances(account_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_type: The account type  (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :param list[datetime] activation_period: The minimum / maximum user activation date. Only taken into account if searching as administrator or managing broker. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param str address_result: Determines which address is returned on the search, if any. By default no addresses are returned. This option is useful for displaying results as locations on a map. In all cases only located addresses (those that have the geographical coordinates set) are returned. When returning all addresses, data related with multiple addresses is returned multiple times. Possible values are: * all: All addresses are returned. * nearest: The nearest address from the reference location is returned. Only usable if a reference coordinate (`latitude` and `longitude`) * none: Addresses are not returned. * primary: The primary (default) user address is returned 
        :param list[int] balance_range: The minimum and / or maximum balance for users to be returned. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param list[str] brokers: Either id or a principal (login name, e-mail, etc) for brokers 
        :param list[datetime] creation_period: The minimum / maximum user creation date. Only taken into account if searching as administrator or managing broker. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param list[str] groups: Either id or internal names of groups / group sets 
        :param bool include_group: When set to `true` and the logged user has permission to view user groups, will return the `group` property on users.  
        :param bool include_group_set: When set to `true` and the logged user has permission to view user group sets, will return the `groupSet` property on users.  
        :param str keywords: Textual search keywords. Sometimes, like in user search, the fields matched depends on what is configured on the products. 
        :param list[datetime] last_incoming_transfer_period: The minimum / maximum date of the last incoming transfer for users to be returned. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param list[datetime] last_login_period: The minimum / maximum user last login date. Only taken into account if searching as administrator or managing broker. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param list[datetime] last_outgoing_transfer_period: The minimum / maximum date of the last outgoing transfer for users to be returned. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param float latitude: The reference latitude for distance searches 
        :param float longitude: The reference longitude for distance searches 
        :param bool main_broker_only: When set to `true`, will match only users that have the brokers as set in the `brokers` parameter as main broker.  
        :param float max_distance: Maximum straight-line distance between the informed location and the resulting address. Is measured either in kilometers or miles, depending on the configuration. Only accepted if both `longitude` and `latitude` parameters are passed with the actual reference position. 
        :param list[int] medium_balance_range: An array with 2 elements, describing the lower and upper medium balance bounds. If not specified, the range defined in the account type will be used. If that one is also not defined, there will be no definitions for balance levels. Both bounds need to be set as 2 element in the array, or it won't be considered. 
        :param list[datetime] negative_since_period: The minimum / maximum negative-since date for users to be returned. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param str order_by: Contains the possible 'order by' values when searching for users with balances  Possible values are: * alphabeticallyAsc: Users are ordered by name (or whatever field is set to format users) in ascending order. * alphabeticallyDesc: Users are ordered by name (or whatever field is set to format users) in descending order. * balanceAsc: User are ordered by balance, lower balances first. * balanceDesc: User are ordered by balance, higher balances first. 
        :param int page: The page number (zero-based) of the search. The default value is zero. 
        :param int page_size: The maximum number of records that will be returned on the search. The default value is 40. The maximum number of returned results is configured in Cyclos, and even if more than that is requested, it will be limited by that setting. 
        :param list[str] profile_fields: User profile fields, both basic (full name, login name, phone, e-mail, etc) and custom fields, that are used for search. Is a comma-separated array, where each part consists in two parts: the internal name (or custom field id) of the field, and a value, both separated by : (colon). For example, `profileFields=field1:value1,field2:value2`. Sometimes multiple values are accepted. In this case, the multiple values are separated by pipes. For example, `profileFields=field1:valueA|valueB`. The accepted fields depend on the products the authenticated user has. Enumerated fields accept multiple values, while numeric and date fields also accept ranges, which are two values, pipe-separated. For example, `profileFields=rank:bronze|silver,birthDate:2000-01-01|2001-12-31` would match results whose custom field with internal name 'rank' is either bronze or silver, and whose 'birthDate' is between January 1, 2000 and December 31, 2001. To specify a single bound in ranges (like birth dates before December 31, 2001), use a pipe in one of the values, like `profileFields=birthDate:|2001-12-31`. The basic profile fields have one of the following identifiers: * `name` or `fullName`: Full name; * `username`, `loginName` or `login`: Login name; * `email`: E-mail; * `phone`: Phone; * `accountNumber`, `account`: Account number; * `image`: Image (accepts a boolean value, indicating that either it   is required that users either have images or not).  If address is an allowed profile field for search, specific address fields may be searched. The allowed ones are normally returned as the `addressFieldsInSearch` field in the corresponding result from a data-for-search request.  The specific address fields are: * `address`: Searches on any address field (not a specific field); * `address.address`: Searches on the fields that represent the   street address, which are `addressLine1`,    `addressLine2`,   `street`,   `buildingNumber` and   `complement`. Note that normally only a   subset of them should be enabled in the configuration (either line   1 / 2 or street + number + complement);  * `address.zip`: Searches for matching zip (postal) code; * `address.poBox`: Searches for matching postal box; * `address.neighborhood`: Searches by neighborhood; * `address.city`: Searches by city; * `address.region`: Searches by region (or state); * `address.country`: Searches by ISO 3166-1 alpha-2 country code.  A note for dynamic custom fields: If a script is used to generate possible values for search, the list will be returned in the  corresponding data, and it is sent as a pipe-separated list of values (not labels). For example: `profileFields=dynamic:a|b|c`. However, it is also possible to perform a keywords-like (full-text) search using the dynamic value label. In this case a single value, prefixed by single quotes should be used. For example: `profileFields=dynamic:'business`. 
        :param list[str] users_to_exclude: Indicated the users to be excluded from the result 
        :param list[str] users_to_include: Indicated the users to be included in the result.  Any other user not present in this list will be excluded from the result. 
        :return: list[UserWithBalanceResult]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search_users_with_balances_with_http_info(account_type, **kwargs)  # noqa: E501
        else:
            (data) = self.search_users_with_balances_with_http_info(account_type, **kwargs)  # noqa: E501
            return data

    def search_users_with_balances_with_http_info(self, account_type, **kwargs):  # noqa: E501
        """Searches for users together with balance information  # noqa: E501

        Returns the users, together with their balances   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_users_with_balances_with_http_info(account_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_type: The account type  (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :param list[datetime] activation_period: The minimum / maximum user activation date. Only taken into account if searching as administrator or managing broker. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param str address_result: Determines which address is returned on the search, if any. By default no addresses are returned. This option is useful for displaying results as locations on a map. In all cases only located addresses (those that have the geographical coordinates set) are returned. When returning all addresses, data related with multiple addresses is returned multiple times. Possible values are: * all: All addresses are returned. * nearest: The nearest address from the reference location is returned. Only usable if a reference coordinate (`latitude` and `longitude`) * none: Addresses are not returned. * primary: The primary (default) user address is returned 
        :param list[int] balance_range: The minimum and / or maximum balance for users to be returned. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param list[str] brokers: Either id or a principal (login name, e-mail, etc) for brokers 
        :param list[datetime] creation_period: The minimum / maximum user creation date. Only taken into account if searching as administrator or managing broker. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param list[str] groups: Either id or internal names of groups / group sets 
        :param bool include_group: When set to `true` and the logged user has permission to view user groups, will return the `group` property on users.  
        :param bool include_group_set: When set to `true` and the logged user has permission to view user group sets, will return the `groupSet` property on users.  
        :param str keywords: Textual search keywords. Sometimes, like in user search, the fields matched depends on what is configured on the products. 
        :param list[datetime] last_incoming_transfer_period: The minimum / maximum date of the last incoming transfer for users to be returned. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param list[datetime] last_login_period: The minimum / maximum user last login date. Only taken into account if searching as administrator or managing broker. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param list[datetime] last_outgoing_transfer_period: The minimum / maximum date of the last outgoing transfer for users to be returned. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param float latitude: The reference latitude for distance searches 
        :param float longitude: The reference longitude for distance searches 
        :param bool main_broker_only: When set to `true`, will match only users that have the brokers as set in the `brokers` parameter as main broker.  
        :param float max_distance: Maximum straight-line distance between the informed location and the resulting address. Is measured either in kilometers or miles, depending on the configuration. Only accepted if both `longitude` and `latitude` parameters are passed with the actual reference position. 
        :param list[int] medium_balance_range: An array with 2 elements, describing the lower and upper medium balance bounds. If not specified, the range defined in the account type will be used. If that one is also not defined, there will be no definitions for balance levels. Both bounds need to be set as 2 element in the array, or it won't be considered. 
        :param list[datetime] negative_since_period: The minimum / maximum negative-since date for users to be returned. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param str order_by: Contains the possible 'order by' values when searching for users with balances  Possible values are: * alphabeticallyAsc: Users are ordered by name (or whatever field is set to format users) in ascending order. * alphabeticallyDesc: Users are ordered by name (or whatever field is set to format users) in descending order. * balanceAsc: User are ordered by balance, lower balances first. * balanceDesc: User are ordered by balance, higher balances first. 
        :param int page: The page number (zero-based) of the search. The default value is zero. 
        :param int page_size: The maximum number of records that will be returned on the search. The default value is 40. The maximum number of returned results is configured in Cyclos, and even if more than that is requested, it will be limited by that setting. 
        :param list[str] profile_fields: User profile fields, both basic (full name, login name, phone, e-mail, etc) and custom fields, that are used for search. Is a comma-separated array, where each part consists in two parts: the internal name (or custom field id) of the field, and a value, both separated by : (colon). For example, `profileFields=field1:value1,field2:value2`. Sometimes multiple values are accepted. In this case, the multiple values are separated by pipes. For example, `profileFields=field1:valueA|valueB`. The accepted fields depend on the products the authenticated user has. Enumerated fields accept multiple values, while numeric and date fields also accept ranges, which are two values, pipe-separated. For example, `profileFields=rank:bronze|silver,birthDate:2000-01-01|2001-12-31` would match results whose custom field with internal name 'rank' is either bronze or silver, and whose 'birthDate' is between January 1, 2000 and December 31, 2001. To specify a single bound in ranges (like birth dates before December 31, 2001), use a pipe in one of the values, like `profileFields=birthDate:|2001-12-31`. The basic profile fields have one of the following identifiers: * `name` or `fullName`: Full name; * `username`, `loginName` or `login`: Login name; * `email`: E-mail; * `phone`: Phone; * `accountNumber`, `account`: Account number; * `image`: Image (accepts a boolean value, indicating that either it   is required that users either have images or not).  If address is an allowed profile field for search, specific address fields may be searched. The allowed ones are normally returned as the `addressFieldsInSearch` field in the corresponding result from a data-for-search request.  The specific address fields are: * `address`: Searches on any address field (not a specific field); * `address.address`: Searches on the fields that represent the   street address, which are `addressLine1`,    `addressLine2`,   `street`,   `buildingNumber` and   `complement`. Note that normally only a   subset of them should be enabled in the configuration (either line   1 / 2 or street + number + complement);  * `address.zip`: Searches for matching zip (postal) code; * `address.poBox`: Searches for matching postal box; * `address.neighborhood`: Searches by neighborhood; * `address.city`: Searches by city; * `address.region`: Searches by region (or state); * `address.country`: Searches by ISO 3166-1 alpha-2 country code.  A note for dynamic custom fields: If a script is used to generate possible values for search, the list will be returned in the  corresponding data, and it is sent as a pipe-separated list of values (not labels). For example: `profileFields=dynamic:a|b|c`. However, it is also possible to perform a keywords-like (full-text) search using the dynamic value label. In this case a single value, prefixed by single quotes should be used. For example: `profileFields=dynamic:'business`. 
        :param list[str] users_to_exclude: Indicated the users to be excluded from the result 
        :param list[str] users_to_include: Indicated the users to be included in the result.  Any other user not present in this list will be excluded from the result. 
        :return: list[UserWithBalanceResult]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_type', 'fields', 'activation_period', 'address_result', 'balance_range', 'brokers', 'creation_period', 'groups', 'include_group', 'include_group_set', 'keywords', 'last_incoming_transfer_period', 'last_login_period', 'last_outgoing_transfer_period', 'latitude', 'longitude', 'main_broker_only', 'max_distance', 'medium_balance_range', 'negative_since_period', 'order_by', 'page', 'page_size', 'profile_fields', 'users_to_exclude', 'users_to_include']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_users_with_balances" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_type' is set
        if self.api_client.client_side_validation and ('account_type' not in params or
                                                       params['account_type'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `account_type` when calling `search_users_with_balances`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_type' in params:
            path_params['accountType'] = params['account_type']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if 'activation_period' in params:
            query_params.append(('activationPeriod', params['activation_period']))  # noqa: E501
            collection_formats['activationPeriod'] = 'csv'  # noqa: E501
        if 'address_result' in params:
            query_params.append(('addressResult', params['address_result']))  # noqa: E501
        if 'balance_range' in params:
            query_params.append(('balanceRange', params['balance_range']))  # noqa: E501
            collection_formats['balanceRange'] = 'csv'  # noqa: E501
        if 'brokers' in params:
            query_params.append(('brokers', params['brokers']))  # noqa: E501
            collection_formats['brokers'] = 'csv'  # noqa: E501
        if 'creation_period' in params:
            query_params.append(('creationPeriod', params['creation_period']))  # noqa: E501
            collection_formats['creationPeriod'] = 'csv'  # noqa: E501
        if 'groups' in params:
            query_params.append(('groups', params['groups']))  # noqa: E501
            collection_formats['groups'] = 'csv'  # noqa: E501
        if 'include_group' in params:
            query_params.append(('includeGroup', params['include_group']))  # noqa: E501
        if 'include_group_set' in params:
            query_params.append(('includeGroupSet', params['include_group_set']))  # noqa: E501
        if 'keywords' in params:
            query_params.append(('keywords', params['keywords']))  # noqa: E501
        if 'last_incoming_transfer_period' in params:
            query_params.append(('lastIncomingTransferPeriod', params['last_incoming_transfer_period']))  # noqa: E501
            collection_formats['lastIncomingTransferPeriod'] = 'csv'  # noqa: E501
        if 'last_login_period' in params:
            query_params.append(('lastLoginPeriod', params['last_login_period']))  # noqa: E501
            collection_formats['lastLoginPeriod'] = 'csv'  # noqa: E501
        if 'last_outgoing_transfer_period' in params:
            query_params.append(('lastOutgoingTransferPeriod', params['last_outgoing_transfer_period']))  # noqa: E501
            collection_formats['lastOutgoingTransferPeriod'] = 'csv'  # noqa: E501
        if 'latitude' in params:
            query_params.append(('latitude', params['latitude']))  # noqa: E501
        if 'longitude' in params:
            query_params.append(('longitude', params['longitude']))  # noqa: E501
        if 'main_broker_only' in params:
            query_params.append(('mainBrokerOnly', params['main_broker_only']))  # noqa: E501
        if 'max_distance' in params:
            query_params.append(('maxDistance', params['max_distance']))  # noqa: E501
        if 'medium_balance_range' in params:
            query_params.append(('mediumBalanceRange', params['medium_balance_range']))  # noqa: E501
            collection_formats['mediumBalanceRange'] = 'csv'  # noqa: E501
        if 'negative_since_period' in params:
            query_params.append(('negativeSincePeriod', params['negative_since_period']))  # noqa: E501
            collection_formats['negativeSincePeriod'] = 'csv'  # noqa: E501
        if 'order_by' in params:
            query_params.append(('orderBy', params['order_by']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'profile_fields' in params:
            query_params.append(('profileFields', params['profile_fields']))  # noqa: E501
            collection_formats['profileFields'] = 'csv'  # noqa: E501
        if 'users_to_exclude' in params:
            query_params.append(('usersToExclude', params['users_to_exclude']))  # noqa: E501
            collection_formats['usersToExclude'] = 'csv'  # noqa: E501
        if 'users_to_include' in params:
            query_params.append(('usersToInclude', params['users_to_include']))  # noqa: E501
            collection_formats['usersToInclude'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['accessClient', 'basic', 'session']  # noqa: E501

        return self.api_client.call_api(
            '/accounts/{accountType}/user-balances', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[UserWithBalanceResult]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
