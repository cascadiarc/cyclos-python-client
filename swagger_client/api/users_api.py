# coding: utf-8

"""
    Cyclos 4.11.5 API

    The REST API for Cyclos 4.11.5  # noqa: E501

    OpenAPI spec version: 4.11.5
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class UsersApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_user(self, body, **kwargs):  # noqa: E501
        """Registers a new user  # noqa: E501

        Can either be a public registration, requiring no authorization, or a user registration by an administrator or broker. The public registration normally requires a CAPTCHA challenge to prevent bots. On user registration the following data is also created:  * Address;  * Mobile phone;  * Landline phone;  * Images.   After the registration those data are managed separately than the user profile data.    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_user(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UserNew body: The user to be registered (required)
        :return: UserRegistrationResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_user_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_user_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_user_with_http_info(self, body, **kwargs):  # noqa: E501
        """Registers a new user  # noqa: E501

        Can either be a public registration, requiring no authorization, or a user registration by an administrator or broker. The public registration normally requires a CAPTCHA challenge to prevent bots. On user registration the following data is also created:  * Address;  * Mobile phone;  * Landline phone;  * Images.   After the registration those data are managed separately than the user profile data.    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_user_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UserNew body: The user to be registered (required)
        :return: UserRegistrationResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `create_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UserRegistrationResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_data_for_edit_full_profile(self, user, **kwargs):  # noqa: E501
        """Returns data for editing the full profile at once  # noqa: E501

        The returned data contains all profile-related entities: such as profile fields, phones, addresses, images and additional contact information   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_data_for_edit_full_profile(user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: Can be one of: * a user identification value, such as id, username, e-mail, phone, etc.   Id is always allowed, others depend on Cyclos configuration. Note that   a valid numeric value is always considered as id. For example, when   using another identification method that can be numeric only, prefix   the value with a single quote (like in Excel spreadsheets), for   example, `'1234567890`;     * `self` for the currently authenticated user.  (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :return: DataForEditFullProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_data_for_edit_full_profile_with_http_info(user, **kwargs)  # noqa: E501
        else:
            (data) = self.get_data_for_edit_full_profile_with_http_info(user, **kwargs)  # noqa: E501
            return data

    def get_data_for_edit_full_profile_with_http_info(self, user, **kwargs):  # noqa: E501
        """Returns data for editing the full profile at once  # noqa: E501

        The returned data contains all profile-related entities: such as profile fields, phones, addresses, images and additional contact information   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_data_for_edit_full_profile_with_http_info(user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: Can be one of: * a user identification value, such as id, username, e-mail, phone, etc.   Id is always allowed, others depend on Cyclos configuration. Note that   a valid numeric value is always considered as id. For example, when   using another identification method that can be numeric only, prefix   the value with a single quote (like in Excel spreadsheets), for   example, `'1234567890`;     * `self` for the currently authenticated user.  (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :return: DataForEditFullProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_data_for_edit_full_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user' is set
        if self.api_client.client_side_validation and ('user' not in params or
                                                       params['user'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user` when calling `get_data_for_edit_full_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user' in params:
            path_params['user'] = params['user']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/{user}/data-for-edit-profile', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DataForEditFullProfile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_data_for_map_directory(self, **kwargs):  # noqa: E501
        """Get configuration data for searching the user directory (map)  # noqa: E501

        Returns data with the current configuration regarding the user  directory (map)   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_data_for_map_directory(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :return: UserDataForMap
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_data_for_map_directory_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_data_for_map_directory_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_data_for_map_directory_with_http_info(self, **kwargs):  # noqa: E501
        """Get configuration data for searching the user directory (map)  # noqa: E501

        Returns data with the current configuration regarding the user  directory (map)   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_data_for_map_directory_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :return: UserDataForMap
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_data_for_map_directory" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/map/data-for-search', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UserDataForMap',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_groups_for_user_registration(self, **kwargs):  # noqa: E501
        """Returns the groups the authenticated user or guest can register on  # noqa: E501

        Returns the list of groups the authenticated user can use to perform a new user registration. If authenticated as guest, will return the groups currently set for public registration. When there is an authenticated administrator, broker or member, will be the configured groups for new users.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_groups_for_user_registration(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :param bool as_member: Flag required only when the authenticated user is a member and a broker, in that case we need to distingish between both. If true then the groups returned will be those allowed as member, otherwise will return the goups allowed as broker.   
        :return: list[GroupForRegistration]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_groups_for_user_registration_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_groups_for_user_registration_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_groups_for_user_registration_with_http_info(self, **kwargs):  # noqa: E501
        """Returns the groups the authenticated user or guest can register on  # noqa: E501

        Returns the list of groups the authenticated user can use to perform a new user registration. If authenticated as guest, will return the groups currently set for public registration. When there is an authenticated administrator, broker or member, will be the configured groups for new users.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_groups_for_user_registration_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :param bool as_member: Flag required only when the authenticated user is a member and a broker, in that case we need to distingish between both. If true then the groups returned will be those allowed as member, otherwise will return the goups allowed as broker.   
        :return: list[GroupForRegistration]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'as_member']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_groups_for_user_registration" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if 'as_member' in params:
            query_params.append(('asMember', params['as_member']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/groups-for-registration', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[GroupForRegistration]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_user_data_for_edit(self, user, **kwargs):  # noqa: E501
        """Get configuration data to edit a user profile  # noqa: E501

        Returns data to edit a user profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_data_for_edit(user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: Can be one of: * a user identification value, such as id, username, e-mail, phone, etc.   Id is always allowed, others depend on Cyclos configuration. Note that   a valid numeric value is always considered as id. For example, when   using another identification method that can be numeric only, prefix   the value with a single quote (like in Excel spreadsheets), for   example, `'1234567890`;     * `self` for the currently authenticated user.  (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :return: UserDataForEdit
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_user_data_for_edit_with_http_info(user, **kwargs)  # noqa: E501
        else:
            (data) = self.get_user_data_for_edit_with_http_info(user, **kwargs)  # noqa: E501
            return data

    def get_user_data_for_edit_with_http_info(self, user, **kwargs):  # noqa: E501
        """Get configuration data to edit a user profile  # noqa: E501

        Returns data to edit a user profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_data_for_edit_with_http_info(user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: Can be one of: * a user identification value, such as id, username, e-mail, phone, etc.   Id is always allowed, others depend on Cyclos configuration. Note that   a valid numeric value is always considered as id. For example, when   using another identification method that can be numeric only, prefix   the value with a single quote (like in Excel spreadsheets), for   example, `'1234567890`;     * `self` for the currently authenticated user.  (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :return: UserDataForEdit
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user_data_for_edit" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user' is set
        if self.api_client.client_side_validation and ('user' not in params or
                                                       params['user'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user` when calling `get_user_data_for_edit`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user' in params:
            path_params['user'] = params['user']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['accessClient', 'basic', 'session']  # noqa: E501

        return self.api_client.call_api(
            '/users/{user}/data-for-edit', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UserDataForEdit',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_user_data_for_new(self, group, **kwargs):  # noqa: E501
        """Get configuration data for registering new users  # noqa: E501

        Almost every aspect of a user profile is configurable in Cyclos, such as enabled basic profile fields, custom profile fields, address fields, phone configuration and so on. As such, if a front-end needs to be robust to such a dynamic nature, it should get this information in order to create a correct registration form.    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_data_for_new(group, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group: The intial group for the new user (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :param bool as_member: Flag required only when the authenticated user is a member and a broker, in that case we need to distingish between both. If true then the configuration data for registering new users as member will be returned, otherwise will return the configuration data for registering as broker.           
        :return: UserDataForNew
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_user_data_for_new_with_http_info(group, **kwargs)  # noqa: E501
        else:
            (data) = self.get_user_data_for_new_with_http_info(group, **kwargs)  # noqa: E501
            return data

    def get_user_data_for_new_with_http_info(self, group, **kwargs):  # noqa: E501
        """Get configuration data for registering new users  # noqa: E501

        Almost every aspect of a user profile is configurable in Cyclos, such as enabled basic profile fields, custom profile fields, address fields, phone configuration and so on. As such, if a front-end needs to be robust to such a dynamic nature, it should get this information in order to create a correct registration form.    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_data_for_new_with_http_info(group, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group: The intial group for the new user (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :param bool as_member: Flag required only when the authenticated user is a member and a broker, in that case we need to distingish between both. If true then the configuration data for registering new users as member will be returned, otherwise will return the configuration data for registering as broker.           
        :return: UserDataForNew
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group', 'fields', 'as_member']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user_data_for_new" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group' is set
        if self.api_client.client_side_validation and ('group' not in params or
                                                       params['group'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group` when calling `get_user_data_for_new`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if 'group' in params:
            query_params.append(('group', params['group']))  # noqa: E501
        if 'as_member' in params:
            query_params.append(('asMember', params['as_member']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/data-for-new', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UserDataForNew',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_user_data_for_search(self, **kwargs):  # noqa: E501
        """Get configuration data for searching users  # noqa: E501

        Returns data with the current configuration regarding the user search   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_data_for_search(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :return: UserDataForSearch
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_user_data_for_search_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_user_data_for_search_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_user_data_for_search_with_http_info(self, **kwargs):  # noqa: E501
        """Get configuration data for searching users  # noqa: E501

        Returns data with the current configuration regarding the user search   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_data_for_search_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :return: UserDataForSearch
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user_data_for_search" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/data-for-search', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UserDataForSearch',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def save_user_full_profile(self, user, body, **kwargs):  # noqa: E501
        """Edits the full profile at once  # noqa: E501

        Saves in a single, transactional operation, the full user profile, that is: allows saving the basic fields and creating / modifying / removing phones, addresses, additional contacts and images at once.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.save_user_full_profile(user, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: Can be one of: * a user identification value, such as id, username, e-mail, phone, etc.   Id is always allowed, others depend on Cyclos configuration. Note that   a valid numeric value is always considered as id. For example, when   using another identification method that can be numeric only, prefix   the value with a single quote (like in Excel spreadsheets), for   example, `'1234567890`;     * `self` for the currently authenticated user.  (required)
        :param FullProfileEdit body: The full profile data (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :param str confirmation_password: The password used to confirm this action, if needed. The actual password type, if any, depends on the Cyclos configuration for the current channel. 
        :return: FullProfileEditResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.save_user_full_profile_with_http_info(user, body, **kwargs)  # noqa: E501
        else:
            (data) = self.save_user_full_profile_with_http_info(user, body, **kwargs)  # noqa: E501
            return data

    def save_user_full_profile_with_http_info(self, user, body, **kwargs):  # noqa: E501
        """Edits the full profile at once  # noqa: E501

        Saves in a single, transactional operation, the full user profile, that is: allows saving the basic fields and creating / modifying / removing phones, addresses, additional contacts and images at once.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.save_user_full_profile_with_http_info(user, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: Can be one of: * a user identification value, such as id, username, e-mail, phone, etc.   Id is always allowed, others depend on Cyclos configuration. Note that   a valid numeric value is always considered as id. For example, when   using another identification method that can be numeric only, prefix   the value with a single quote (like in Excel spreadsheets), for   example, `'1234567890`;     * `self` for the currently authenticated user.  (required)
        :param FullProfileEdit body: The full profile data (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :param str confirmation_password: The password used to confirm this action, if needed. The actual password type, if any, depends on the Cyclos configuration for the current channel. 
        :return: FullProfileEditResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user', 'body', 'fields', 'confirmation_password']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method save_user_full_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user' is set
        if self.api_client.client_side_validation and ('user' not in params or
                                                       params['user'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user` when calling `save_user_full_profile`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `save_user_full_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user' in params:
            path_params['user'] = params['user']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501

        header_params = {}
        if 'confirmation_password' in params:
            header_params['confirmationPassword'] = params['confirmation_password']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/{user}/profile', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FullProfileEditResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_map_directory(self, **kwargs):  # noqa: E501
        """Search the user directory (map)  # noqa: E501

        Returns a page of users in the map directory that match a given criteria   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_map_directory(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :param list[datetime] activation_period: The minimum / maximum user activation date. Only taken into account if searching as administrator or managing broker. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param str address_result: Determines which address is returned on the search, if any. By default no addresses are returned. This option is useful for displaying results as locations on a map. In all cases only located addresses (those that have the geographical coordinates set) are returned. When returning all addresses, data related with multiple addresses is returned multiple times. Possible values are: * all: All addresses are returned. * nearest: The nearest address from the reference location is returned. Only usable if a reference coordinate (`latitude` and `longitude`) * none: Addresses are not returned. * primary: The primary (default) user address is returned 
        :param list[str] brokers: Either id or a principal (login name, e-mail, etc) for brokers 
        :param list[datetime] creation_period: The minimum / maximum user creation date. Only taken into account if searching as administrator or managing broker. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param bool exclude_contacts: When set to `true` will not return any user that is already a contact of the currently authenticated user. 
        :param list[str] groups: Either id or internal names of groups / group sets 
        :param bool ignore_profile_fields_in_list: When set to `true`, instead of returning users with corresponding profile fields set on list, will return them with `display` and `shortDisplay`.  
        :param bool include_group: When set to `true` and the logged user has permission to view user groups, will return the `group` property on users.  
        :param bool include_group_set: When set to `true` and the logged user has permission to view user group sets, will return the `groupSet` property on users.  
        :param str keywords: Textual search keywords. Sometimes, like in user search, the fields matched depends on what is configured on the products. 
        :param list[datetime] last_login_period: The minimum / maximum user last login date. Only taken into account if searching as administrator or managing broker. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param float latitude: The reference latitude for distance searches 
        :param float longitude: The reference longitude for distance searches 
        :param bool main_broker_only: When set to `true`, will match only users that have the brokers as set in the `brokers` parameter as main broker.  
        :param float max_distance: Maximum straight-line distance between the informed location and the resulting address. Is measured either in kilometers or miles, depending on the configuration. Only accepted if both `longitude` and `latitude` parameters are passed with the actual reference position. 
        :param str order_by: Possible options for ordering the results of an user search. Possible values are: * alphabeticallyAsc: Users are ordered by name (or whatever field is set to format users) in ascending order. * alphabeticallyDesc: Users are ordered by name (or whatever field is set to format users) in descending order. * creationDate: Newly registered users are returned first. * distance: Only useful when providing a location, will return nearer advertisements first. * random: Users will be randomly returned * relevance: This is the default if keywords are used. Best matching users come first. 
        :param int page: The page number (zero-based) of the search. The default value is zero. 
        :param int page_size: The maximum number of records that will be returned on the search. The default value is 40. The maximum number of returned results is configured in Cyclos, and even if more than that is requested, it will be limited by that setting. 
        :param list[str] profile_fields: User profile fields, both basic (full name, login name, phone, e-mail, etc) and custom fields, that are used for search. Is a comma-separated array, where each part consists in two parts: the internal name (or custom field id) of the field, and a value, both separated by : (colon). For example, `profileFields=field1:value1,field2:value2`. Sometimes multiple values are accepted. In this case, the multiple values are separated by pipes. For example, `profileFields=field1:valueA|valueB`. The accepted fields depend on the products the authenticated user has. Enumerated fields accept multiple values, while numeric and date fields also accept ranges, which are two values, pipe-separated. For example, `profileFields=rank:bronze|silver,birthDate:2000-01-01|2001-12-31` would match results whose custom field with internal name 'rank' is either bronze or silver, and whose 'birthDate' is between January 1, 2000 and December 31, 2001. To specify a single bound in ranges (like birth dates before December 31, 2001), use a pipe in one of the values, like `profileFields=birthDate:|2001-12-31`. The basic profile fields have one of the following identifiers: * `name` or `fullName`: Full name; * `username`, `loginName` or `login`: Login name; * `email`: E-mail; * `phone`: Phone; * `accountNumber`, `account`: Account number; * `image`: Image (accepts a boolean value, indicating that either it   is required that users either have images or not).  If address is an allowed profile field for search, specific address fields may be searched. The allowed ones are normally returned as the `addressFieldsInSearch` field in the corresponding result from a data-for-search request.  The specific address fields are: * `address`: Searches on any address field (not a specific field); * `address.address`: Searches on the fields that represent the   street address, which are `addressLine1`,    `addressLine2`,   `street`,   `buildingNumber` and   `complement`. Note that normally only a   subset of them should be enabled in the configuration (either line   1 / 2 or street + number + complement);  * `address.zip`: Searches for matching zip (postal) code; * `address.poBox`: Searches for matching postal box; * `address.neighborhood`: Searches by neighborhood; * `address.city`: Searches by city; * `address.region`: Searches by region (or state); * `address.country`: Searches by ISO 3166-1 alpha-2 country code.  A note for dynamic custom fields: If a script is used to generate possible values for search, the list will be returned in the  corresponding data, and it is sent as a pipe-separated list of values (not labels). For example: `profileFields=dynamic:a|b|c`. However, it is also possible to perform a keywords-like (full-text) search using the dynamic value label. In this case a single value, prefixed by single quotes should be used. For example: `profileFields=dynamic:'business`. 
        :param list[str] roles: The main role the user has. Possible values for each array element are: * administrator: A user who can manage the system and other users. * broker: A user who can manage other users. * member: A regular user who can manage operators.  * operator: A \"sub-user\" created by a member to manage his data. 
        :param list[str] statuses: The possible statuses for an user Possible values for each array element are: * active: The user is active and can use the system normally. * blocked: The user has been blocked from accessing the system. Other users still see him/her. * disabled: The user has been disabled - he/she cannot access the system and is invisible by other users. * pending: The user registration is pending a confirmation. Probably the user has received an e-mail with a link that must be followed to complete the activation. The user is invisible by other users. * purged: The user was permanently removed and had all his private data removed. Only transactions are kept for historical reasons. * removed: The user was permanently removed. It's profile is kept for historical purposes. 
        :param list[str] users_to_exclude: Indicated the users to be excluded from the result 
        :param list[str] users_to_include: Indicated the users to be included in the result.  Any other user not present in this list will be excluded from the result. 
        :return: list[UserResult]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search_map_directory_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_map_directory_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_map_directory_with_http_info(self, **kwargs):  # noqa: E501
        """Search the user directory (map)  # noqa: E501

        Returns a page of users in the map directory that match a given criteria   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_map_directory_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :param list[datetime] activation_period: The minimum / maximum user activation date. Only taken into account if searching as administrator or managing broker. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param str address_result: Determines which address is returned on the search, if any. By default no addresses are returned. This option is useful for displaying results as locations on a map. In all cases only located addresses (those that have the geographical coordinates set) are returned. When returning all addresses, data related with multiple addresses is returned multiple times. Possible values are: * all: All addresses are returned. * nearest: The nearest address from the reference location is returned. Only usable if a reference coordinate (`latitude` and `longitude`) * none: Addresses are not returned. * primary: The primary (default) user address is returned 
        :param list[str] brokers: Either id or a principal (login name, e-mail, etc) for brokers 
        :param list[datetime] creation_period: The minimum / maximum user creation date. Only taken into account if searching as administrator or managing broker. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param bool exclude_contacts: When set to `true` will not return any user that is already a contact of the currently authenticated user. 
        :param list[str] groups: Either id or internal names of groups / group sets 
        :param bool ignore_profile_fields_in_list: When set to `true`, instead of returning users with corresponding profile fields set on list, will return them with `display` and `shortDisplay`.  
        :param bool include_group: When set to `true` and the logged user has permission to view user groups, will return the `group` property on users.  
        :param bool include_group_set: When set to `true` and the logged user has permission to view user group sets, will return the `groupSet` property on users.  
        :param str keywords: Textual search keywords. Sometimes, like in user search, the fields matched depends on what is configured on the products. 
        :param list[datetime] last_login_period: The minimum / maximum user last login date. Only taken into account if searching as administrator or managing broker. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param float latitude: The reference latitude for distance searches 
        :param float longitude: The reference longitude for distance searches 
        :param bool main_broker_only: When set to `true`, will match only users that have the brokers as set in the `brokers` parameter as main broker.  
        :param float max_distance: Maximum straight-line distance between the informed location and the resulting address. Is measured either in kilometers or miles, depending on the configuration. Only accepted if both `longitude` and `latitude` parameters are passed with the actual reference position. 
        :param str order_by: Possible options for ordering the results of an user search. Possible values are: * alphabeticallyAsc: Users are ordered by name (or whatever field is set to format users) in ascending order. * alphabeticallyDesc: Users are ordered by name (or whatever field is set to format users) in descending order. * creationDate: Newly registered users are returned first. * distance: Only useful when providing a location, will return nearer advertisements first. * random: Users will be randomly returned * relevance: This is the default if keywords are used. Best matching users come first. 
        :param int page: The page number (zero-based) of the search. The default value is zero. 
        :param int page_size: The maximum number of records that will be returned on the search. The default value is 40. The maximum number of returned results is configured in Cyclos, and even if more than that is requested, it will be limited by that setting. 
        :param list[str] profile_fields: User profile fields, both basic (full name, login name, phone, e-mail, etc) and custom fields, that are used for search. Is a comma-separated array, where each part consists in two parts: the internal name (or custom field id) of the field, and a value, both separated by : (colon). For example, `profileFields=field1:value1,field2:value2`. Sometimes multiple values are accepted. In this case, the multiple values are separated by pipes. For example, `profileFields=field1:valueA|valueB`. The accepted fields depend on the products the authenticated user has. Enumerated fields accept multiple values, while numeric and date fields also accept ranges, which are two values, pipe-separated. For example, `profileFields=rank:bronze|silver,birthDate:2000-01-01|2001-12-31` would match results whose custom field with internal name 'rank' is either bronze or silver, and whose 'birthDate' is between January 1, 2000 and December 31, 2001. To specify a single bound in ranges (like birth dates before December 31, 2001), use a pipe in one of the values, like `profileFields=birthDate:|2001-12-31`. The basic profile fields have one of the following identifiers: * `name` or `fullName`: Full name; * `username`, `loginName` or `login`: Login name; * `email`: E-mail; * `phone`: Phone; * `accountNumber`, `account`: Account number; * `image`: Image (accepts a boolean value, indicating that either it   is required that users either have images or not).  If address is an allowed profile field for search, specific address fields may be searched. The allowed ones are normally returned as the `addressFieldsInSearch` field in the corresponding result from a data-for-search request.  The specific address fields are: * `address`: Searches on any address field (not a specific field); * `address.address`: Searches on the fields that represent the   street address, which are `addressLine1`,    `addressLine2`,   `street`,   `buildingNumber` and   `complement`. Note that normally only a   subset of them should be enabled in the configuration (either line   1 / 2 or street + number + complement);  * `address.zip`: Searches for matching zip (postal) code; * `address.poBox`: Searches for matching postal box; * `address.neighborhood`: Searches by neighborhood; * `address.city`: Searches by city; * `address.region`: Searches by region (or state); * `address.country`: Searches by ISO 3166-1 alpha-2 country code.  A note for dynamic custom fields: If a script is used to generate possible values for search, the list will be returned in the  corresponding data, and it is sent as a pipe-separated list of values (not labels). For example: `profileFields=dynamic:a|b|c`. However, it is also possible to perform a keywords-like (full-text) search using the dynamic value label. In this case a single value, prefixed by single quotes should be used. For example: `profileFields=dynamic:'business`. 
        :param list[str] roles: The main role the user has. Possible values for each array element are: * administrator: A user who can manage the system and other users. * broker: A user who can manage other users. * member: A regular user who can manage operators.  * operator: A \"sub-user\" created by a member to manage his data. 
        :param list[str] statuses: The possible statuses for an user Possible values for each array element are: * active: The user is active and can use the system normally. * blocked: The user has been blocked from accessing the system. Other users still see him/her. * disabled: The user has been disabled - he/she cannot access the system and is invisible by other users. * pending: The user registration is pending a confirmation. Probably the user has received an e-mail with a link that must be followed to complete the activation. The user is invisible by other users. * purged: The user was permanently removed and had all his private data removed. Only transactions are kept for historical reasons. * removed: The user was permanently removed. It's profile is kept for historical purposes. 
        :param list[str] users_to_exclude: Indicated the users to be excluded from the result 
        :param list[str] users_to_include: Indicated the users to be included in the result.  Any other user not present in this list will be excluded from the result. 
        :return: list[UserResult]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'activation_period', 'address_result', 'brokers', 'creation_period', 'exclude_contacts', 'groups', 'ignore_profile_fields_in_list', 'include_group', 'include_group_set', 'keywords', 'last_login_period', 'latitude', 'longitude', 'main_broker_only', 'max_distance', 'order_by', 'page', 'page_size', 'profile_fields', 'roles', 'statuses', 'users_to_exclude', 'users_to_include']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_map_directory" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if 'activation_period' in params:
            query_params.append(('activationPeriod', params['activation_period']))  # noqa: E501
            collection_formats['activationPeriod'] = 'csv'  # noqa: E501
        if 'address_result' in params:
            query_params.append(('addressResult', params['address_result']))  # noqa: E501
        if 'brokers' in params:
            query_params.append(('brokers', params['brokers']))  # noqa: E501
            collection_formats['brokers'] = 'csv'  # noqa: E501
        if 'creation_period' in params:
            query_params.append(('creationPeriod', params['creation_period']))  # noqa: E501
            collection_formats['creationPeriod'] = 'csv'  # noqa: E501
        if 'exclude_contacts' in params:
            query_params.append(('excludeContacts', params['exclude_contacts']))  # noqa: E501
        if 'groups' in params:
            query_params.append(('groups', params['groups']))  # noqa: E501
            collection_formats['groups'] = 'csv'  # noqa: E501
        if 'ignore_profile_fields_in_list' in params:
            query_params.append(('ignoreProfileFieldsInList', params['ignore_profile_fields_in_list']))  # noqa: E501
        if 'include_group' in params:
            query_params.append(('includeGroup', params['include_group']))  # noqa: E501
        if 'include_group_set' in params:
            query_params.append(('includeGroupSet', params['include_group_set']))  # noqa: E501
        if 'keywords' in params:
            query_params.append(('keywords', params['keywords']))  # noqa: E501
        if 'last_login_period' in params:
            query_params.append(('lastLoginPeriod', params['last_login_period']))  # noqa: E501
            collection_formats['lastLoginPeriod'] = 'csv'  # noqa: E501
        if 'latitude' in params:
            query_params.append(('latitude', params['latitude']))  # noqa: E501
        if 'longitude' in params:
            query_params.append(('longitude', params['longitude']))  # noqa: E501
        if 'main_broker_only' in params:
            query_params.append(('mainBrokerOnly', params['main_broker_only']))  # noqa: E501
        if 'max_distance' in params:
            query_params.append(('maxDistance', params['max_distance']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('orderBy', params['order_by']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'profile_fields' in params:
            query_params.append(('profileFields', params['profile_fields']))  # noqa: E501
            collection_formats['profileFields'] = 'csv'  # noqa: E501
        if 'roles' in params:
            query_params.append(('roles', params['roles']))  # noqa: E501
            collection_formats['roles'] = 'csv'  # noqa: E501
        if 'statuses' in params:
            query_params.append(('statuses', params['statuses']))  # noqa: E501
            collection_formats['statuses'] = 'csv'  # noqa: E501
        if 'users_to_exclude' in params:
            query_params.append(('usersToExclude', params['users_to_exclude']))  # noqa: E501
            collection_formats['usersToExclude'] = 'csv'  # noqa: E501
        if 'users_to_include' in params:
            query_params.append(('usersToInclude', params['users_to_include']))  # noqa: E501
            collection_formats['usersToInclude'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/map', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[UserResult]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_users(self, **kwargs):  # noqa: E501
        """Search for users  # noqa: E501

        Returns a page of users that match a given criteria. The fields returned depend on the products, in the profile fields of other users setting. Only fields (both basic or custom) marked to be returned on user list are returned. If no fields are set to be returned, or if the `ignoreProfileFieldsInList` flag is true in the given query then the resulting objects will have the `display` and `shortDisplay` filled in.  However, those fields are not returned when another profile field is returned, preventing duplicated data to be returned.    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_users(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :param list[datetime] activation_period: The minimum / maximum user activation date. Only taken into account if searching as administrator or managing broker. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param str address_result: Determines which address is returned on the search, if any. By default no addresses are returned. This option is useful for displaying results as locations on a map. In all cases only located addresses (those that have the geographical coordinates set) are returned. When returning all addresses, data related with multiple addresses is returned multiple times. Possible values are: * all: All addresses are returned. * nearest: The nearest address from the reference location is returned. Only usable if a reference coordinate (`latitude` and `longitude`) * none: Addresses are not returned. * primary: The primary (default) user address is returned 
        :param list[str] brokers: Either id or a principal (login name, e-mail, etc) for brokers 
        :param list[datetime] creation_period: The minimum / maximum user creation date. Only taken into account if searching as administrator or managing broker. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param bool exclude_contacts: When set to `true` will not return any user that is already a contact of the currently authenticated user. 
        :param list[str] groups: Either id or internal names of groups / group sets 
        :param bool ignore_profile_fields_in_list: When set to `true`, instead of returning users with corresponding profile fields set on list, will return them with `display` and `shortDisplay`.  
        :param bool include_group: When set to `true` and the logged user has permission to view user groups, will return the `group` property on users.  
        :param bool include_group_set: When set to `true` and the logged user has permission to view user group sets, will return the `groupSet` property on users.  
        :param str keywords: Textual search keywords. Sometimes, like in user search, the fields matched depends on what is configured on the products. 
        :param list[datetime] last_login_period: The minimum / maximum user last login date. Only taken into account if searching as administrator or managing broker. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param float latitude: The reference latitude for distance searches 
        :param float longitude: The reference longitude for distance searches 
        :param bool main_broker_only: When set to `true`, will match only users that have the brokers as set in the `brokers` parameter as main broker.  
        :param float max_distance: Maximum straight-line distance between the informed location and the resulting address. Is measured either in kilometers or miles, depending on the configuration. Only accepted if both `longitude` and `latitude` parameters are passed with the actual reference position. 
        :param str order_by: Possible options for ordering the results of an user search. Possible values are: * alphabeticallyAsc: Users are ordered by name (or whatever field is set to format users) in ascending order. * alphabeticallyDesc: Users are ordered by name (or whatever field is set to format users) in descending order. * creationDate: Newly registered users are returned first. * distance: Only useful when providing a location, will return nearer advertisements first. * random: Users will be randomly returned * relevance: This is the default if keywords are used. Best matching users come first. 
        :param int page: The page number (zero-based) of the search. The default value is zero. 
        :param int page_size: The maximum number of records that will be returned on the search. The default value is 40. The maximum number of returned results is configured in Cyclos, and even if more than that is requested, it will be limited by that setting. 
        :param list[str] profile_fields: User profile fields, both basic (full name, login name, phone, e-mail, etc) and custom fields, that are used for search. Is a comma-separated array, where each part consists in two parts: the internal name (or custom field id) of the field, and a value, both separated by : (colon). For example, `profileFields=field1:value1,field2:value2`. Sometimes multiple values are accepted. In this case, the multiple values are separated by pipes. For example, `profileFields=field1:valueA|valueB`. The accepted fields depend on the products the authenticated user has. Enumerated fields accept multiple values, while numeric and date fields also accept ranges, which are two values, pipe-separated. For example, `profileFields=rank:bronze|silver,birthDate:2000-01-01|2001-12-31` would match results whose custom field with internal name 'rank' is either bronze or silver, and whose 'birthDate' is between January 1, 2000 and December 31, 2001. To specify a single bound in ranges (like birth dates before December 31, 2001), use a pipe in one of the values, like `profileFields=birthDate:|2001-12-31`. The basic profile fields have one of the following identifiers: * `name` or `fullName`: Full name; * `username`, `loginName` or `login`: Login name; * `email`: E-mail; * `phone`: Phone; * `accountNumber`, `account`: Account number; * `image`: Image (accepts a boolean value, indicating that either it   is required that users either have images or not).  If address is an allowed profile field for search, specific address fields may be searched. The allowed ones are normally returned as the `addressFieldsInSearch` field in the corresponding result from a data-for-search request.  The specific address fields are: * `address`: Searches on any address field (not a specific field); * `address.address`: Searches on the fields that represent the   street address, which are `addressLine1`,    `addressLine2`,   `street`,   `buildingNumber` and   `complement`. Note that normally only a   subset of them should be enabled in the configuration (either line   1 / 2 or street + number + complement);  * `address.zip`: Searches for matching zip (postal) code; * `address.poBox`: Searches for matching postal box; * `address.neighborhood`: Searches by neighborhood; * `address.city`: Searches by city; * `address.region`: Searches by region (or state); * `address.country`: Searches by ISO 3166-1 alpha-2 country code.  A note for dynamic custom fields: If a script is used to generate possible values for search, the list will be returned in the  corresponding data, and it is sent as a pipe-separated list of values (not labels). For example: `profileFields=dynamic:a|b|c`. However, it is also possible to perform a keywords-like (full-text) search using the dynamic value label. In this case a single value, prefixed by single quotes should be used. For example: `profileFields=dynamic:'business`. 
        :param list[str] roles: The main role the user has. Possible values for each array element are: * administrator: A user who can manage the system and other users. * broker: A user who can manage other users. * member: A regular user who can manage operators.  * operator: A \"sub-user\" created by a member to manage his data. 
        :param list[str] statuses: The possible statuses for an user Possible values for each array element are: * active: The user is active and can use the system normally. * blocked: The user has been blocked from accessing the system. Other users still see him/her. * disabled: The user has been disabled - he/she cannot access the system and is invisible by other users. * pending: The user registration is pending a confirmation. Probably the user has received an e-mail with a link that must be followed to complete the activation. The user is invisible by other users. * purged: The user was permanently removed and had all his private data removed. Only transactions are kept for historical reasons. * removed: The user was permanently removed. It's profile is kept for historical purposes. 
        :param list[str] users_to_exclude: Indicated the users to be excluded from the result 
        :param list[str] users_to_include: Indicated the users to be included in the result.  Any other user not present in this list will be excluded from the result. 
        :return: list[UserResult]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search_users_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_users_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_users_with_http_info(self, **kwargs):  # noqa: E501
        """Search for users  # noqa: E501

        Returns a page of users that match a given criteria. The fields returned depend on the products, in the profile fields of other users setting. Only fields (both basic or custom) marked to be returned on user list are returned. If no fields are set to be returned, or if the `ignoreProfileFieldsInList` flag is true in the given query then the resulting objects will have the `display` and `shortDisplay` filled in.  However, those fields are not returned when another profile field is returned, preventing duplicated data to be returned.    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_users_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :param list[datetime] activation_period: The minimum / maximum user activation date. Only taken into account if searching as administrator or managing broker. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param str address_result: Determines which address is returned on the search, if any. By default no addresses are returned. This option is useful for displaying results as locations on a map. In all cases only located addresses (those that have the geographical coordinates set) are returned. When returning all addresses, data related with multiple addresses is returned multiple times. Possible values are: * all: All addresses are returned. * nearest: The nearest address from the reference location is returned. Only usable if a reference coordinate (`latitude` and `longitude`) * none: Addresses are not returned. * primary: The primary (default) user address is returned 
        :param list[str] brokers: Either id or a principal (login name, e-mail, etc) for brokers 
        :param list[datetime] creation_period: The minimum / maximum user creation date. Only taken into account if searching as administrator or managing broker. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param bool exclude_contacts: When set to `true` will not return any user that is already a contact of the currently authenticated user. 
        :param list[str] groups: Either id or internal names of groups / group sets 
        :param bool ignore_profile_fields_in_list: When set to `true`, instead of returning users with corresponding profile fields set on list, will return them with `display` and `shortDisplay`.  
        :param bool include_group: When set to `true` and the logged user has permission to view user groups, will return the `group` property on users.  
        :param bool include_group_set: When set to `true` and the logged user has permission to view user group sets, will return the `groupSet` property on users.  
        :param str keywords: Textual search keywords. Sometimes, like in user search, the fields matched depends on what is configured on the products. 
        :param list[datetime] last_login_period: The minimum / maximum user last login date. Only taken into account if searching as administrator or managing broker. Is expressed an array, with the lower bound as first element, and the upper bound as second element. When only one element, will have just the lower bound. To specify only the upper bound, prefix the value with a comma. 
        :param float latitude: The reference latitude for distance searches 
        :param float longitude: The reference longitude for distance searches 
        :param bool main_broker_only: When set to `true`, will match only users that have the brokers as set in the `brokers` parameter as main broker.  
        :param float max_distance: Maximum straight-line distance between the informed location and the resulting address. Is measured either in kilometers or miles, depending on the configuration. Only accepted if both `longitude` and `latitude` parameters are passed with the actual reference position. 
        :param str order_by: Possible options for ordering the results of an user search. Possible values are: * alphabeticallyAsc: Users are ordered by name (or whatever field is set to format users) in ascending order. * alphabeticallyDesc: Users are ordered by name (or whatever field is set to format users) in descending order. * creationDate: Newly registered users are returned first. * distance: Only useful when providing a location, will return nearer advertisements first. * random: Users will be randomly returned * relevance: This is the default if keywords are used. Best matching users come first. 
        :param int page: The page number (zero-based) of the search. The default value is zero. 
        :param int page_size: The maximum number of records that will be returned on the search. The default value is 40. The maximum number of returned results is configured in Cyclos, and even if more than that is requested, it will be limited by that setting. 
        :param list[str] profile_fields: User profile fields, both basic (full name, login name, phone, e-mail, etc) and custom fields, that are used for search. Is a comma-separated array, where each part consists in two parts: the internal name (or custom field id) of the field, and a value, both separated by : (colon). For example, `profileFields=field1:value1,field2:value2`. Sometimes multiple values are accepted. In this case, the multiple values are separated by pipes. For example, `profileFields=field1:valueA|valueB`. The accepted fields depend on the products the authenticated user has. Enumerated fields accept multiple values, while numeric and date fields also accept ranges, which are two values, pipe-separated. For example, `profileFields=rank:bronze|silver,birthDate:2000-01-01|2001-12-31` would match results whose custom field with internal name 'rank' is either bronze or silver, and whose 'birthDate' is between January 1, 2000 and December 31, 2001. To specify a single bound in ranges (like birth dates before December 31, 2001), use a pipe in one of the values, like `profileFields=birthDate:|2001-12-31`. The basic profile fields have one of the following identifiers: * `name` or `fullName`: Full name; * `username`, `loginName` or `login`: Login name; * `email`: E-mail; * `phone`: Phone; * `accountNumber`, `account`: Account number; * `image`: Image (accepts a boolean value, indicating that either it   is required that users either have images or not).  If address is an allowed profile field for search, specific address fields may be searched. The allowed ones are normally returned as the `addressFieldsInSearch` field in the corresponding result from a data-for-search request.  The specific address fields are: * `address`: Searches on any address field (not a specific field); * `address.address`: Searches on the fields that represent the   street address, which are `addressLine1`,    `addressLine2`,   `street`,   `buildingNumber` and   `complement`. Note that normally only a   subset of them should be enabled in the configuration (either line   1 / 2 or street + number + complement);  * `address.zip`: Searches for matching zip (postal) code; * `address.poBox`: Searches for matching postal box; * `address.neighborhood`: Searches by neighborhood; * `address.city`: Searches by city; * `address.region`: Searches by region (or state); * `address.country`: Searches by ISO 3166-1 alpha-2 country code.  A note for dynamic custom fields: If a script is used to generate possible values for search, the list will be returned in the  corresponding data, and it is sent as a pipe-separated list of values (not labels). For example: `profileFields=dynamic:a|b|c`. However, it is also possible to perform a keywords-like (full-text) search using the dynamic value label. In this case a single value, prefixed by single quotes should be used. For example: `profileFields=dynamic:'business`. 
        :param list[str] roles: The main role the user has. Possible values for each array element are: * administrator: A user who can manage the system and other users. * broker: A user who can manage other users. * member: A regular user who can manage operators.  * operator: A \"sub-user\" created by a member to manage his data. 
        :param list[str] statuses: The possible statuses for an user Possible values for each array element are: * active: The user is active and can use the system normally. * blocked: The user has been blocked from accessing the system. Other users still see him/her. * disabled: The user has been disabled - he/she cannot access the system and is invisible by other users. * pending: The user registration is pending a confirmation. Probably the user has received an e-mail with a link that must be followed to complete the activation. The user is invisible by other users. * purged: The user was permanently removed and had all his private data removed. Only transactions are kept for historical reasons. * removed: The user was permanently removed. It's profile is kept for historical purposes. 
        :param list[str] users_to_exclude: Indicated the users to be excluded from the result 
        :param list[str] users_to_include: Indicated the users to be included in the result.  Any other user not present in this list will be excluded from the result. 
        :return: list[UserResult]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'activation_period', 'address_result', 'brokers', 'creation_period', 'exclude_contacts', 'groups', 'ignore_profile_fields_in_list', 'include_group', 'include_group_set', 'keywords', 'last_login_period', 'latitude', 'longitude', 'main_broker_only', 'max_distance', 'order_by', 'page', 'page_size', 'profile_fields', 'roles', 'statuses', 'users_to_exclude', 'users_to_include']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_users" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if 'activation_period' in params:
            query_params.append(('activationPeriod', params['activation_period']))  # noqa: E501
            collection_formats['activationPeriod'] = 'csv'  # noqa: E501
        if 'address_result' in params:
            query_params.append(('addressResult', params['address_result']))  # noqa: E501
        if 'brokers' in params:
            query_params.append(('brokers', params['brokers']))  # noqa: E501
            collection_formats['brokers'] = 'csv'  # noqa: E501
        if 'creation_period' in params:
            query_params.append(('creationPeriod', params['creation_period']))  # noqa: E501
            collection_formats['creationPeriod'] = 'csv'  # noqa: E501
        if 'exclude_contacts' in params:
            query_params.append(('excludeContacts', params['exclude_contacts']))  # noqa: E501
        if 'groups' in params:
            query_params.append(('groups', params['groups']))  # noqa: E501
            collection_formats['groups'] = 'csv'  # noqa: E501
        if 'ignore_profile_fields_in_list' in params:
            query_params.append(('ignoreProfileFieldsInList', params['ignore_profile_fields_in_list']))  # noqa: E501
        if 'include_group' in params:
            query_params.append(('includeGroup', params['include_group']))  # noqa: E501
        if 'include_group_set' in params:
            query_params.append(('includeGroupSet', params['include_group_set']))  # noqa: E501
        if 'keywords' in params:
            query_params.append(('keywords', params['keywords']))  # noqa: E501
        if 'last_login_period' in params:
            query_params.append(('lastLoginPeriod', params['last_login_period']))  # noqa: E501
            collection_formats['lastLoginPeriod'] = 'csv'  # noqa: E501
        if 'latitude' in params:
            query_params.append(('latitude', params['latitude']))  # noqa: E501
        if 'longitude' in params:
            query_params.append(('longitude', params['longitude']))  # noqa: E501
        if 'main_broker_only' in params:
            query_params.append(('mainBrokerOnly', params['main_broker_only']))  # noqa: E501
        if 'max_distance' in params:
            query_params.append(('maxDistance', params['max_distance']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('orderBy', params['order_by']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'profile_fields' in params:
            query_params.append(('profileFields', params['profile_fields']))  # noqa: E501
            collection_formats['profileFields'] = 'csv'  # noqa: E501
        if 'roles' in params:
            query_params.append(('roles', params['roles']))  # noqa: E501
            collection_formats['roles'] = 'csv'  # noqa: E501
        if 'statuses' in params:
            query_params.append(('statuses', params['statuses']))  # noqa: E501
            collection_formats['statuses'] = 'csv'  # noqa: E501
        if 'users_to_exclude' in params:
            query_params.append(('usersToExclude', params['users_to_exclude']))  # noqa: E501
            collection_formats['usersToExclude'] = 'csv'  # noqa: E501
        if 'users_to_include' in params:
            query_params.append(('usersToInclude', params['users_to_include']))  # noqa: E501
            collection_formats['usersToInclude'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[UserResult]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_user(self, user, body, **kwargs):  # noqa: E501
        """Save a user details  # noqa: E501

        Saves the user profile. Only the basic fields (full name, login name, e-mail) and custom fields can be saved with this operation. Addresses, phones and images must be managed through their own paths.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_user(user, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: Can be one of: * a user identification value, such as id, username, e-mail, phone, etc.   Id is always allowed, others depend on Cyclos configuration. Note that   a valid numeric value is always considered as id. For example, when   using another identification method that can be numeric only, prefix   the value with a single quote (like in Excel spreadsheets), for   example, `'1234567890`;     * `self` for the currently authenticated user.  (required)
        :param UserEdit body: The user to be saved (required)
        :param str confirmation_password: The password used to confirm this action, if needed. The actual password type, if any, depends on the Cyclos configuration for the current channel. 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_user_with_http_info(user, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_user_with_http_info(user, body, **kwargs)  # noqa: E501
            return data

    def update_user_with_http_info(self, user, body, **kwargs):  # noqa: E501
        """Save a user details  # noqa: E501

        Saves the user profile. Only the basic fields (full name, login name, e-mail) and custom fields can be saved with this operation. Addresses, phones and images must be managed through their own paths.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_user_with_http_info(user, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: Can be one of: * a user identification value, such as id, username, e-mail, phone, etc.   Id is always allowed, others depend on Cyclos configuration. Note that   a valid numeric value is always considered as id. For example, when   using another identification method that can be numeric only, prefix   the value with a single quote (like in Excel spreadsheets), for   example, `'1234567890`;     * `self` for the currently authenticated user.  (required)
        :param UserEdit body: The user to be saved (required)
        :param str confirmation_password: The password used to confirm this action, if needed. The actual password type, if any, depends on the Cyclos configuration for the current channel. 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user', 'body', 'confirmation_password']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user' is set
        if self.api_client.client_side_validation and ('user' not in params or
                                                       params['user'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user` when calling `update_user`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `update_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user' in params:
            path_params['user'] = params['user']  # noqa: E501

        query_params = []

        header_params = {}
        if 'confirmation_password' in params:
            header_params['confirmationPassword'] = params['confirmation_password']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['accessClient', 'basic', 'session']  # noqa: E501

        return self.api_client.call_api(
            '/users/{user}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def validate_email_change(self, key, **kwargs):  # noqa: E501
        """Validates an e-mail via a validation key  # noqa: E501

        When the user e-mail is changed, and the configuration enables the validation, an e-mail is sent to the new user e-mail, with a link to verify it. In this case, only after verifying the new e-mail it is effectively set as the new e-mail. This operation effectively verifies the new e-mail.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.validate_email_change(key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str key: The validation key sent via e-mail (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.validate_email_change_with_http_info(key, **kwargs)  # noqa: E501
        else:
            (data) = self.validate_email_change_with_http_info(key, **kwargs)  # noqa: E501
            return data

    def validate_email_change_with_http_info(self, key, **kwargs):  # noqa: E501
        """Validates an e-mail via a validation key  # noqa: E501

        When the user e-mail is changed, and the configuration enables the validation, an e-mail is sent to the new user e-mail, with a link to verify it. In this case, only after verifying the new e-mail it is effectively set as the new e-mail. This operation effectively verifies the new e-mail.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.validate_email_change_with_http_info(key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str key: The validation key sent via e-mail (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method validate_email_change" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'key' is set
        if self.api_client.client_side_validation and ('key' not in params or
                                                       params['key'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `key` when calling `validate_email_change`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'key' in params:
            path_params['key'] = params['key']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/validate/email-change/{key}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def validate_user_registration(self, key, **kwargs):  # noqa: E501
        """Validates an user registration via a key sent by e-mail  # noqa: E501

        When a user is registered, and the configuration enables the validation, an e-mail is sent to user e-mail, with a link to verify it. In this case, only after verifying the e-mail the user is activated. This operation effectively verifies the e-mail and performs the user activation. However, depending on the settings, the initial user status might be blocked or inactive.     # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.validate_user_registration(key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str key: The validation key sent via e-mail (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :return: UserRegistrationResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.validate_user_registration_with_http_info(key, **kwargs)  # noqa: E501
        else:
            (data) = self.validate_user_registration_with_http_info(key, **kwargs)  # noqa: E501
            return data

    def validate_user_registration_with_http_info(self, key, **kwargs):  # noqa: E501
        """Validates an user registration via a key sent by e-mail  # noqa: E501

        When a user is registered, and the configuration enables the validation, an e-mail is sent to user e-mail, with a link to verify it. In this case, only after verifying the e-mail the user is activated. This operation effectively verifies the e-mail and performs the user activation. However, depending on the settings, the initial user status might be blocked or inactive.     # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.validate_user_registration_with_http_info(key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str key: The validation key sent via e-mail (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :return: UserRegistrationResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['key', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method validate_user_registration" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'key' is set
        if self.api_client.client_side_validation and ('key' not in params or
                                                       params['key'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `key` when calling `validate_user_registration`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'key' in params:
            path_params['key'] = params['key']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/validate/registration/{key}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UserRegistrationResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def validate_user_registration_field(self, group, field, value, **kwargs):  # noqa: E501
        """Validates the value of a single field for user registration  # noqa: E501

        Validates the value of a field which will be used for registering a user, returning either `204 No Content` if the field is valid or `200` with the error description if the field is invalid. Notice that the result is the validation error. If a `422` status code is returned it means that either the given `field` is invalid or the given `value` is empty.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.validate_user_registration_field(group, field, value, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group: The internal name or id of the group in which the user is being registered   (required)
        :param str field: One of: `name` (full name), `username` (login name), `email`, `mobilePhone`, `landLinePhone` or the internal name of a custom field.   (required)
        :param str value: The value to be validated (required)
        :param bool as_member: Flag required only when the authenticated user is a member and a broker, in that case we need to distingish between both. If true then the groups returned will be those allowed as member, otherwise will return the goups allowed as broker.   
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.validate_user_registration_field_with_http_info(group, field, value, **kwargs)  # noqa: E501
        else:
            (data) = self.validate_user_registration_field_with_http_info(group, field, value, **kwargs)  # noqa: E501
            return data

    def validate_user_registration_field_with_http_info(self, group, field, value, **kwargs):  # noqa: E501
        """Validates the value of a single field for user registration  # noqa: E501

        Validates the value of a field which will be used for registering a user, returning either `204 No Content` if the field is valid or `200` with the error description if the field is invalid. Notice that the result is the validation error. If a `422` status code is returned it means that either the given `field` is invalid or the given `value` is empty.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.validate_user_registration_field_with_http_info(group, field, value, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group: The internal name or id of the group in which the user is being registered   (required)
        :param str field: One of: `name` (full name), `username` (login name), `email`, `mobilePhone`, `landLinePhone` or the internal name of a custom field.   (required)
        :param str value: The value to be validated (required)
        :param bool as_member: Flag required only when the authenticated user is a member and a broker, in that case we need to distingish between both. If true then the groups returned will be those allowed as member, otherwise will return the goups allowed as broker.   
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group', 'field', 'value', 'as_member']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method validate_user_registration_field" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group' is set
        if self.api_client.client_side_validation and ('group' not in params or
                                                       params['group'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `group` when calling `validate_user_registration_field`")  # noqa: E501
        # verify the required parameter 'field' is set
        if self.api_client.client_side_validation and ('field' not in params or
                                                       params['field'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `field` when calling `validate_user_registration_field`")  # noqa: E501
        # verify the required parameter 'value' is set
        if self.api_client.client_side_validation and ('value' not in params or
                                                       params['value'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `value` when calling `validate_user_registration_field`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group' in params:
            path_params['group'] = params['group']  # noqa: E501
        if 'field' in params:
            path_params['field'] = params['field']  # noqa: E501

        query_params = []
        if 'value' in params:
            query_params.append(('value', params['value']))  # noqa: E501
        if 'as_member' in params:
            query_params.append(('asMember', params['as_member']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/validate/{group}/{field}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def view_user(self, user, **kwargs):  # noqa: E501
        """View a user details  # noqa: E501

        Returns the profile information of a user / operator.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.view_user(user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: Can be one of: * a user identification value, such as id, username, e-mail, phone, etc.   Id is always allowed, others depend on Cyclos configuration. Note that   a valid numeric value is always considered as id. For example, when   using another identification method that can be numeric only, prefix   the value with a single quote (like in Excel spreadsheets), for   example, `'1234567890`;     * `self` for the currently authenticated user.  (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :return: UserView
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.view_user_with_http_info(user, **kwargs)  # noqa: E501
        else:
            (data) = self.view_user_with_http_info(user, **kwargs)  # noqa: E501
            return data

    def view_user_with_http_info(self, user, **kwargs):  # noqa: E501
        """View a user details  # noqa: E501

        Returns the profile information of a user / operator.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.view_user_with_http_info(user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: Can be one of: * a user identification value, such as id, username, e-mail, phone, etc.   Id is always allowed, others depend on Cyclos configuration. Note that   a valid numeric value is always considered as id. For example, when   using another identification method that can be numeric only, prefix   the value with a single quote (like in Excel spreadsheets), for   example, `'1234567890`;     * `self` for the currently authenticated user.  (required)
        :param list[str] fields: Select which fields to include on returned data. If nothing is set, all object fields are returned. Unprefixed field names will be handled like a whitelist (only listed fields will be included), while names starting with a minus (-) or exclamation mark (!) will be handled as blacklist (listed fields will not be included). This works for nesting as well. For example: `a,b.b1,c.-c1,c.-c2` will return the fields `a`, `b` (containing only the `b1` field) and `c` (containing all its fields except for `c1` or `c2`).  
        :return: UserView
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method view_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user' is set
        if self.api_client.client_side_validation and ('user' not in params or
                                                       params['user'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user` when calling `view_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user' in params:
            path_params['user'] = params['user']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/{user}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UserView',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
