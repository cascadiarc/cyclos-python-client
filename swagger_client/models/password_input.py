# coding: utf-8

"""
    Cyclos 4.11.5 API

    The REST API for Cyclos 4.11.5  # noqa: E501

    OpenAPI spec version: 4.11.5
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


import pprint
import re  # noqa: F401

import six

from swagger_client.configuration import Configuration


class PasswordInput(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'input_method': 'PasswordInputMethodEnum',
        'mode': 'PasswordModeEnum',
        'has_active_password': 'bool',
        'confirmation_password_once_per_session': 'bool',
        'min_length': 'int',
        'max_length': 'int',
        'otp_send_mediums': 'list[SendMediumEnum]',
        'number_of_buttons': 'int',
        'buttons_per_row': 'int',
        'buttons': 'list[list[str]]'
    }

    attribute_map = {
        'input_method': 'inputMethod',
        'mode': 'mode',
        'has_active_password': 'hasActivePassword',
        'confirmation_password_once_per_session': 'confirmationPasswordOncePerSession',
        'min_length': 'minLength',
        'max_length': 'maxLength',
        'otp_send_mediums': 'otpSendMediums',
        'number_of_buttons': 'numberOfButtons',
        'buttons_per_row': 'buttonsPerRow',
        'buttons': 'buttons'
    }

    def __init__(self, input_method=None, mode=None, has_active_password=None, confirmation_password_once_per_session=None, min_length=None, max_length=None, otp_send_mediums=None, number_of_buttons=None, buttons_per_row=None, buttons=None, _configuration=None):  # noqa: E501
        """PasswordInput - a model defined in Swagger"""  # noqa: E501
        if _configuration is None:
            _configuration = Configuration()
        self._configuration = _configuration

        self._input_method = None
        self._mode = None
        self._has_active_password = None
        self._confirmation_password_once_per_session = None
        self._min_length = None
        self._max_length = None
        self._otp_send_mediums = None
        self._number_of_buttons = None
        self._buttons_per_row = None
        self._buttons = None
        self.discriminator = None

        if input_method is not None:
            self.input_method = input_method
        if mode is not None:
            self.mode = mode
        if has_active_password is not None:
            self.has_active_password = has_active_password
        if confirmation_password_once_per_session is not None:
            self.confirmation_password_once_per_session = confirmation_password_once_per_session
        if min_length is not None:
            self.min_length = min_length
        if max_length is not None:
            self.max_length = max_length
        if otp_send_mediums is not None:
            self.otp_send_mediums = otp_send_mediums
        if number_of_buttons is not None:
            self.number_of_buttons = number_of_buttons
        if buttons_per_row is not None:
            self.buttons_per_row = buttons_per_row
        if buttons is not None:
            self.buttons = buttons

    @property
    def input_method(self):
        """Gets the input_method of this PasswordInput.  # noqa: E501

        The explanation for the value that should be sent for `virtualKeyboard`  cases is given above, in the description of this type. Possible values are: * textBox: A simple string should be requested * virtualKeyboard: A series of buttons should be presented to allow enter the password.   # noqa: E501

        :return: The input_method of this PasswordInput.  # noqa: E501
        :rtype: PasswordInputMethodEnum
        """
        return self._input_method

    @input_method.setter
    def input_method(self, input_method):
        """Sets the input_method of this PasswordInput.

        The explanation for the value that should be sent for `virtualKeyboard`  cases is given above, in the description of this type. Possible values are: * textBox: A simple string should be requested * virtualKeyboard: A series of buttons should be presented to allow enter the password.   # noqa: E501

        :param input_method: The input_method of this PasswordInput.  # noqa: E501
        :type: PasswordInputMethodEnum
        """

        self._input_method = input_method

    @property
    def mode(self):
        """Gets the mode of this PasswordInput.  # noqa: E501

        Indicates how a password is handled Possible values are: * generated: Passwords are always generated * manual: Passwords are manually typed by users * otp: One Time Passwords. are always generated and can be used only once * script: Passwords are not stored in Cyclos, but handed-over for a script to verify them.  Is normally used to implement single-sign-on with other apps.   # noqa: E501

        :return: The mode of this PasswordInput.  # noqa: E501
        :rtype: PasswordModeEnum
        """
        return self._mode

    @mode.setter
    def mode(self, mode):
        """Sets the mode of this PasswordInput.

        Indicates how a password is handled Possible values are: * generated: Passwords are always generated * manual: Passwords are manually typed by users * otp: One Time Passwords. are always generated and can be used only once * script: Passwords are not stored in Cyclos, but handed-over for a script to verify them.  Is normally used to implement single-sign-on with other apps.   # noqa: E501

        :param mode: The mode of this PasswordInput.  # noqa: E501
        :type: PasswordModeEnum
        """

        self._mode = mode

    @property
    def has_active_password(self):
        """Gets the has_active_password of this PasswordInput.  # noqa: E501

        Only returned when there is an authenticated user (not for login). Describes whether the user has created a password of this type. If not, a proper message can be shown to the user indicating that this password needs to be created.   # noqa: E501

        :return: The has_active_password of this PasswordInput.  # noqa: E501
        :rtype: bool
        """
        return self._has_active_password

    @has_active_password.setter
    def has_active_password(self, has_active_password):
        """Sets the has_active_password of this PasswordInput.

        Only returned when there is an authenticated user (not for login). Describes whether the user has created a password of this type. If not, a proper message can be shown to the user indicating that this password needs to be created.   # noqa: E501

        :param has_active_password: The has_active_password of this PasswordInput.  # noqa: E501
        :type: bool
        """

        self._has_active_password = has_active_password

    @property
    def confirmation_password_once_per_session(self):
        """Gets the confirmation_password_once_per_session of this PasswordInput.  # noqa: E501

        Only returned when there is an authenticated user (not for login). Determines whether this password, when used as confirmation, should be requested only once until the user logs out.   # noqa: E501

        :return: The confirmation_password_once_per_session of this PasswordInput.  # noqa: E501
        :rtype: bool
        """
        return self._confirmation_password_once_per_session

    @confirmation_password_once_per_session.setter
    def confirmation_password_once_per_session(self, confirmation_password_once_per_session):
        """Sets the confirmation_password_once_per_session of this PasswordInput.

        Only returned when there is an authenticated user (not for login). Determines whether this password, when used as confirmation, should be requested only once until the user logs out.   # noqa: E501

        :param confirmation_password_once_per_session: The confirmation_password_once_per_session of this PasswordInput.  # noqa: E501
        :type: bool
        """

        self._confirmation_password_once_per_session = confirmation_password_once_per_session

    @property
    def min_length(self):
        """Gets the min_length of this PasswordInput.  # noqa: E501

        For text passwords, the minimum password length  # noqa: E501

        :return: The min_length of this PasswordInput.  # noqa: E501
        :rtype: int
        """
        return self._min_length

    @min_length.setter
    def min_length(self, min_length):
        """Sets the min_length of this PasswordInput.

        For text passwords, the minimum password length  # noqa: E501

        :param min_length: The min_length of this PasswordInput.  # noqa: E501
        :type: int
        """

        self._min_length = min_length

    @property
    def max_length(self):
        """Gets the max_length of this PasswordInput.  # noqa: E501

        For text passwords, the maximum password length  # noqa: E501

        :return: The max_length of this PasswordInput.  # noqa: E501
        :rtype: int
        """
        return self._max_length

    @max_length.setter
    def max_length(self, max_length):
        """Sets the max_length of this PasswordInput.

        For text passwords, the maximum password length  # noqa: E501

        :param max_length: The max_length of this PasswordInput.  # noqa: E501
        :type: int
        """

        self._max_length = max_length

    @property
    def otp_send_mediums(self):
        """Gets the otp_send_mediums of this PasswordInput.  # noqa: E501

        Only for `otp`, the available mediums for the password to be sent Possibles values for each array element are: * email: The user will receive an email with the information * sms: The user will receive a sms with the information (only if there is at least one phone enabled for sms)   # noqa: E501

        :return: The otp_send_mediums of this PasswordInput.  # noqa: E501
        :rtype: list[SendMediumEnum]
        """
        return self._otp_send_mediums

    @otp_send_mediums.setter
    def otp_send_mediums(self, otp_send_mediums):
        """Sets the otp_send_mediums of this PasswordInput.

        Only for `otp`, the available mediums for the password to be sent Possibles values for each array element are: * email: The user will receive an email with the information * sms: The user will receive a sms with the information (only if there is at least one phone enabled for sms)   # noqa: E501

        :param otp_send_mediums: The otp_send_mediums of this PasswordInput.  # noqa: E501
        :type: list[SendMediumEnum]
        """

        self._otp_send_mediums = otp_send_mediums

    @property
    def number_of_buttons(self):
        """Gets the number_of_buttons of this PasswordInput.  # noqa: E501

        Only for `virtualKeyboard`, is the number of buttons to be displayed   # noqa: E501

        :return: The number_of_buttons of this PasswordInput.  # noqa: E501
        :rtype: int
        """
        return self._number_of_buttons

    @number_of_buttons.setter
    def number_of_buttons(self, number_of_buttons):
        """Sets the number_of_buttons of this PasswordInput.

        Only for `virtualKeyboard`, is the number of buttons to be displayed   # noqa: E501

        :param number_of_buttons: The number_of_buttons of this PasswordInput.  # noqa: E501
        :type: int
        """

        self._number_of_buttons = number_of_buttons

    @property
    def buttons_per_row(self):
        """Gets the buttons_per_row of this PasswordInput.  # noqa: E501

        Only for `virtualKeyboard`, is the number of buttons that should be displayed on each row   # noqa: E501

        :return: The buttons_per_row of this PasswordInput.  # noqa: E501
        :rtype: int
        """
        return self._buttons_per_row

    @buttons_per_row.setter
    def buttons_per_row(self, buttons_per_row):
        """Sets the buttons_per_row of this PasswordInput.

        Only for `virtualKeyboard`, is the number of buttons that should be displayed on each row   # noqa: E501

        :param buttons_per_row: The buttons_per_row of this PasswordInput.  # noqa: E501
        :type: int
        """

        self._buttons_per_row = buttons_per_row

    @property
    def buttons(self):
        """Gets the buttons of this PasswordInput.  # noqa: E501

        Only for `virtualKeyboard`, contains the sequences of buttons that should be displayed for the user. The explanation for the value that should be sent on virtual keyboard mode is shown above, in the description of this type.   # noqa: E501

        :return: The buttons of this PasswordInput.  # noqa: E501
        :rtype: list[list[str]]
        """
        return self._buttons

    @buttons.setter
    def buttons(self, buttons):
        """Sets the buttons of this PasswordInput.

        Only for `virtualKeyboard`, contains the sequences of buttons that should be displayed for the user. The explanation for the value that should be sent on virtual keyboard mode is shown above, in the description of this type.   # noqa: E501

        :param buttons: The buttons of this PasswordInput.  # noqa: E501
        :type: list[list[str]]
        """

        self._buttons = buttons

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(PasswordInput, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, PasswordInput):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, PasswordInput):
            return True

        return self.to_dict() != other.to_dict()
