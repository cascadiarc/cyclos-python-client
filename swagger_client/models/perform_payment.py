# coding: utf-8

"""
    Cyclos 4.11.5 API

    The REST API for Cyclos 4.11.5  # noqa: E501

    OpenAPI spec version: 4.11.5
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


import pprint
import re  # noqa: F401

import six

from swagger_client.configuration import Configuration


class PerformPayment(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'scheduling': 'PaymentSchedulingEnum',
        'installments_count': 'int',
        'first_installment_date': 'datetime',
        'installments': 'list[PerformScheduledPaymentInstallment]',
        'occurrences_count': 'int',
        'first_occurrence_date': 'datetime',
        'occurrence_interval': 'TimeInterval',
        'nfc_challence': 'str'
    }

    attribute_map = {
        'scheduling': 'scheduling',
        'installments_count': 'installmentsCount',
        'first_installment_date': 'firstInstallmentDate',
        'installments': 'installments',
        'occurrences_count': 'occurrencesCount',
        'first_occurrence_date': 'firstOccurrenceDate',
        'occurrence_interval': 'occurrenceInterval',
        'nfc_challence': 'nfcChallence'
    }

    def __init__(self, scheduling=None, installments_count=None, first_installment_date=None, installments=None, occurrences_count=None, first_occurrence_date=None, occurrence_interval=None, nfc_challence=None, _configuration=None):  # noqa: E501
        """PerformPayment - a model defined in Swagger"""  # noqa: E501
        if _configuration is None:
            _configuration = Configuration()
        self._configuration = _configuration

        self._scheduling = None
        self._installments_count = None
        self._first_installment_date = None
        self._installments = None
        self._occurrences_count = None
        self._first_occurrence_date = None
        self._occurrence_interval = None
        self._nfc_challence = None
        self.discriminator = None

        if scheduling is not None:
            self.scheduling = scheduling
        if installments_count is not None:
            self.installments_count = installments_count
        if first_installment_date is not None:
            self.first_installment_date = first_installment_date
        if installments is not None:
            self.installments = installments
        if occurrences_count is not None:
            self.occurrences_count = occurrences_count
        if first_occurrence_date is not None:
            self.first_occurrence_date = first_occurrence_date
        if occurrence_interval is not None:
            self.occurrence_interval = occurrence_interval
        if nfc_challence is not None:
            self.nfc_challence = nfc_challence

    @property
    def scheduling(self):
        """Gets the scheduling of this PerformPayment.  # noqa: E501

        Determines how a payment is scheduled. When not specified, direct payments are performed. Possible values are: * direct: The payment won't be scheduled, but paid directly * recurring: The payment will be recurring, repeated either by a limited number of occurrences or until cancel * scheduled: The payment will be scheduled, either to a single future date or multiple installments   # noqa: E501

        :return: The scheduling of this PerformPayment.  # noqa: E501
        :rtype: PaymentSchedulingEnum
        """
        return self._scheduling

    @scheduling.setter
    def scheduling(self, scheduling):
        """Sets the scheduling of this PerformPayment.

        Determines how a payment is scheduled. When not specified, direct payments are performed. Possible values are: * direct: The payment won't be scheduled, but paid directly * recurring: The payment will be recurring, repeated either by a limited number of occurrences or until cancel * scheduled: The payment will be scheduled, either to a single future date or multiple installments   # noqa: E501

        :param scheduling: The scheduling of this PerformPayment.  # noqa: E501
        :type: PaymentSchedulingEnum
        """

        self._scheduling = scheduling

    @property
    def installments_count(self):
        """Gets the installments_count of this PerformPayment.  # noqa: E501

        Represents the number of installments. When not specified, assumes a single installment. Used only if `scheduling` is `scheduled`. Can be used together with `installmentsCount` as an alternative to providing individual `installments` definitions.   # noqa: E501

        :return: The installments_count of this PerformPayment.  # noqa: E501
        :rtype: int
        """
        return self._installments_count

    @installments_count.setter
    def installments_count(self, installments_count):
        """Sets the installments_count of this PerformPayment.

        Represents the number of installments. When not specified, assumes a single installment. Used only if `scheduling` is `scheduled`. Can be used together with `installmentsCount` as an alternative to providing individual `installments` definitions.   # noqa: E501

        :param installments_count: The installments_count of this PerformPayment.  # noqa: E501
        :type: int
        """
        if (self._configuration.client_side_validation and
                installments_count is not None and installments_count < 1):  # noqa: E501
            raise ValueError("Invalid value for `installments_count`, must be a value greater than or equal to `1`")  # noqa: E501

        self._installments_count = installments_count

    @property
    def first_installment_date(self):
        """Gets the first_installment_date of this PerformPayment.  # noqa: E501

        Represents the first installment date. When not specified, assumes the first installment is processed instantly. Used only if `scheduling` is `scheduled`. Can be used together with `installmentsCount` as an alternative to providing individual `installments` definitions.   # noqa: E501

        :return: The first_installment_date of this PerformPayment.  # noqa: E501
        :rtype: datetime
        """
        return self._first_installment_date

    @first_installment_date.setter
    def first_installment_date(self, first_installment_date):
        """Sets the first_installment_date of this PerformPayment.

        Represents the first installment date. When not specified, assumes the first installment is processed instantly. Used only if `scheduling` is `scheduled`. Can be used together with `installmentsCount` as an alternative to providing individual `installments` definitions.   # noqa: E501

        :param first_installment_date: The first_installment_date of this PerformPayment.  # noqa: E501
        :type: datetime
        """

        self._first_installment_date = first_installment_date

    @property
    def installments(self):
        """Gets the installments of this PerformPayment.  # noqa: E501

        An array containing individual installments definitions, allowing full control over generated installments. Used only if `scheduling` is `scheduled`.   # noqa: E501

        :return: The installments of this PerformPayment.  # noqa: E501
        :rtype: list[PerformScheduledPaymentInstallment]
        """
        return self._installments

    @installments.setter
    def installments(self, installments):
        """Sets the installments of this PerformPayment.

        An array containing individual installments definitions, allowing full control over generated installments. Used only if `scheduling` is `scheduled`.   # noqa: E501

        :param installments: The installments of this PerformPayment.  # noqa: E501
        :type: list[PerformScheduledPaymentInstallment]
        """

        self._installments = installments

    @property
    def occurrences_count(self):
        """Gets the occurrences_count of this PerformPayment.  # noqa: E501

        Represents the number of occurrences in a recurring payment. When not provided, the payment will be repeated until it is manually canceled. Used only if `scheduling` is `recurring`.   # noqa: E501

        :return: The occurrences_count of this PerformPayment.  # noqa: E501
        :rtype: int
        """
        return self._occurrences_count

    @occurrences_count.setter
    def occurrences_count(self, occurrences_count):
        """Sets the occurrences_count of this PerformPayment.

        Represents the number of occurrences in a recurring payment. When not provided, the payment will be repeated until it is manually canceled. Used only if `scheduling` is `recurring`.   # noqa: E501

        :param occurrences_count: The occurrences_count of this PerformPayment.  # noqa: E501
        :type: int
        """
        if (self._configuration.client_side_validation and
                occurrences_count is not None and occurrences_count < 1):  # noqa: E501
            raise ValueError("Invalid value for `occurrences_count`, must be a value greater than or equal to `1`")  # noqa: E501

        self._occurrences_count = occurrences_count

    @property
    def first_occurrence_date(self):
        """Gets the first_occurrence_date of this PerformPayment.  # noqa: E501

        Represents the first occurrence date for a recurring payment. If none is given, it is assumed that the first occurrence is immediate. Used only if `scheduling` is `recurring`.   # noqa: E501

        :return: The first_occurrence_date of this PerformPayment.  # noqa: E501
        :rtype: datetime
        """
        return self._first_occurrence_date

    @first_occurrence_date.setter
    def first_occurrence_date(self, first_occurrence_date):
        """Sets the first_occurrence_date of this PerformPayment.

        Represents the first occurrence date for a recurring payment. If none is given, it is assumed that the first occurrence is immediate. Used only if `scheduling` is `recurring`.   # noqa: E501

        :param first_occurrence_date: The first_occurrence_date of this PerformPayment.  # noqa: E501
        :type: datetime
        """

        self._first_occurrence_date = first_occurrence_date

    @property
    def occurrence_interval(self):
        """Gets the occurrence_interval of this PerformPayment.  # noqa: E501

        Defines the interval between payment occurrences. If none is given, it is assumed 1 month between occurrences. Used only if `scheduling` is `recurring`.   # noqa: E501

        :return: The occurrence_interval of this PerformPayment.  # noqa: E501
        :rtype: TimeInterval
        """
        return self._occurrence_interval

    @occurrence_interval.setter
    def occurrence_interval(self, occurrence_interval):
        """Sets the occurrence_interval of this PerformPayment.

        Defines the interval between payment occurrences. If none is given, it is assumed 1 month between occurrences. Used only if `scheduling` is `recurring`.   # noqa: E501

        :param occurrence_interval: The occurrence_interval of this PerformPayment.  # noqa: E501
        :type: TimeInterval
        """

        self._occurrence_interval = occurrence_interval

    @property
    def nfc_challence(self):
        """Gets the nfc_challence of this PerformPayment.  # noqa: E501

        If this payment is performed with a NFC token, must be the challenge (as returned by the server) encrypted by the NFC chip, encoded in HEX form (2 hex chars per byte).   # noqa: E501

        :return: The nfc_challence of this PerformPayment.  # noqa: E501
        :rtype: str
        """
        return self._nfc_challence

    @nfc_challence.setter
    def nfc_challence(self, nfc_challence):
        """Sets the nfc_challence of this PerformPayment.

        If this payment is performed with a NFC token, must be the challenge (as returned by the server) encrypted by the NFC chip, encoded in HEX form (2 hex chars per byte).   # noqa: E501

        :param nfc_challence: The nfc_challence of this PerformPayment.  # noqa: E501
        :type: str
        """

        self._nfc_challence = nfc_challence

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(PerformPayment, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, PerformPayment):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, PerformPayment):
            return True

        return self.to_dict() != other.to_dict()
