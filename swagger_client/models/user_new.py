# coding: utf-8

"""
    Cyclos 4.11.5 API

    The REST API for Cyclos 4.11.5  # noqa: E501

    OpenAPI spec version: 4.11.5
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


import pprint
import re  # noqa: F401

import six

from swagger_client.configuration import Configuration


class UserNew(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'group': 'str',
        'addresses': 'list[AddressNew]',
        'mobile_phones': 'list[PhoneNew]',
        'land_line_phones': 'list[PhoneNew]',
        'contact_infos': 'list[ContactInfoNew]',
        'passwords': 'list[PasswordRegistration]',
        'images': 'list[str]',
        'captcha': 'CaptchaResponse',
        'accept_agreement': 'bool',
        'skip_activation_email': 'bool',
        'as_member': 'bool',
        'security_question': 'str',
        'security_answer': 'str',
        'nfc_token': 'NfcTokenWithChallengeParameter'
    }

    attribute_map = {
        'group': 'group',
        'addresses': 'addresses',
        'mobile_phones': 'mobilePhones',
        'land_line_phones': 'landLinePhones',
        'contact_infos': 'contactInfos',
        'passwords': 'passwords',
        'images': 'images',
        'captcha': 'captcha',
        'accept_agreement': 'acceptAgreement',
        'skip_activation_email': 'skipActivationEmail',
        'as_member': 'asMember',
        'security_question': 'securityQuestion',
        'security_answer': 'securityAnswer',
        'nfc_token': 'nfcToken'
    }

    def __init__(self, group=None, addresses=None, mobile_phones=None, land_line_phones=None, contact_infos=None, passwords=None, images=None, captcha=None, accept_agreement=None, skip_activation_email=None, as_member=None, security_question=None, security_answer=None, nfc_token=None, _configuration=None):  # noqa: E501
        """UserNew - a model defined in Swagger"""  # noqa: E501
        if _configuration is None:
            _configuration = Configuration()
        self._configuration = _configuration

        self._group = None
        self._addresses = None
        self._mobile_phones = None
        self._land_line_phones = None
        self._contact_infos = None
        self._passwords = None
        self._images = None
        self._captcha = None
        self._accept_agreement = None
        self._skip_activation_email = None
        self._as_member = None
        self._security_question = None
        self._security_answer = None
        self._nfc_token = None
        self.discriminator = None

        if group is not None:
            self.group = group
        if addresses is not None:
            self.addresses = addresses
        if mobile_phones is not None:
            self.mobile_phones = mobile_phones
        if land_line_phones is not None:
            self.land_line_phones = land_line_phones
        if contact_infos is not None:
            self.contact_infos = contact_infos
        if passwords is not None:
            self.passwords = passwords
        if images is not None:
            self.images = images
        if captcha is not None:
            self.captcha = captcha
        if accept_agreement is not None:
            self.accept_agreement = accept_agreement
        if skip_activation_email is not None:
            self.skip_activation_email = skip_activation_email
        if as_member is not None:
            self.as_member = as_member
        if security_question is not None:
            self.security_question = security_question
        if security_answer is not None:
            self.security_answer = security_answer
        if nfc_token is not None:
            self.nfc_token = nfc_token

    @property
    def group(self):
        """Gets the group of this UserNew.  # noqa: E501

        The initial user group  # noqa: E501

        :return: The group of this UserNew.  # noqa: E501
        :rtype: str
        """
        return self._group

    @group.setter
    def group(self, group):
        """Sets the group of this UserNew.

        The initial user group  # noqa: E501

        :param group: The group of this UserNew.  # noqa: E501
        :type: str
        """

        self._group = group

    @property
    def addresses(self):
        """Gets the addresses of this UserNew.  # noqa: E501

        Addresses to be registered together with the user  # noqa: E501

        :return: The addresses of this UserNew.  # noqa: E501
        :rtype: list[AddressNew]
        """
        return self._addresses

    @addresses.setter
    def addresses(self, addresses):
        """Sets the addresses of this UserNew.

        Addresses to be registered together with the user  # noqa: E501

        :param addresses: The addresses of this UserNew.  # noqa: E501
        :type: list[AddressNew]
        """

        self._addresses = addresses

    @property
    def mobile_phones(self):
        """Gets the mobile_phones of this UserNew.  # noqa: E501

        Mobile phones to be registered together with the user  # noqa: E501

        :return: The mobile_phones of this UserNew.  # noqa: E501
        :rtype: list[PhoneNew]
        """
        return self._mobile_phones

    @mobile_phones.setter
    def mobile_phones(self, mobile_phones):
        """Sets the mobile_phones of this UserNew.

        Mobile phones to be registered together with the user  # noqa: E501

        :param mobile_phones: The mobile_phones of this UserNew.  # noqa: E501
        :type: list[PhoneNew]
        """

        self._mobile_phones = mobile_phones

    @property
    def land_line_phones(self):
        """Gets the land_line_phones of this UserNew.  # noqa: E501

        Land-line phones to be registered together with the user  # noqa: E501

        :return: The land_line_phones of this UserNew.  # noqa: E501
        :rtype: list[PhoneNew]
        """
        return self._land_line_phones

    @land_line_phones.setter
    def land_line_phones(self, land_line_phones):
        """Sets the land_line_phones of this UserNew.

        Land-line phones to be registered together with the user  # noqa: E501

        :param land_line_phones: The land_line_phones of this UserNew.  # noqa: E501
        :type: list[PhoneNew]
        """

        self._land_line_phones = land_line_phones

    @property
    def contact_infos(self):
        """Gets the contact_infos of this UserNew.  # noqa: E501

        Additional contacts to be registered together with the user   # noqa: E501

        :return: The contact_infos of this UserNew.  # noqa: E501
        :rtype: list[ContactInfoNew]
        """
        return self._contact_infos

    @contact_infos.setter
    def contact_infos(self, contact_infos):
        """Sets the contact_infos of this UserNew.

        Additional contacts to be registered together with the user   # noqa: E501

        :param contact_infos: The contact_infos of this UserNew.  # noqa: E501
        :type: list[ContactInfoNew]
        """

        self._contact_infos = contact_infos

    @property
    def passwords(self):
        """Gets the passwords of this UserNew.  # noqa: E501

        The initial passwords of the user  # noqa: E501

        :return: The passwords of this UserNew.  # noqa: E501
        :rtype: list[PasswordRegistration]
        """
        return self._passwords

    @passwords.setter
    def passwords(self, passwords):
        """Sets the passwords of this UserNew.

        The initial passwords of the user  # noqa: E501

        :param passwords: The passwords of this UserNew.  # noqa: E501
        :type: list[PasswordRegistration]
        """

        self._passwords = passwords

    @property
    def images(self):
        """Gets the images of this UserNew.  # noqa: E501

        The ids of previously uploaded user temporary images to be initially used as profile images   # noqa: E501

        :return: The images of this UserNew.  # noqa: E501
        :rtype: list[str]
        """
        return self._images

    @images.setter
    def images(self, images):
        """Sets the images of this UserNew.

        The ids of previously uploaded user temporary images to be initially used as profile images   # noqa: E501

        :param images: The images of this UserNew.  # noqa: E501
        :type: list[str]
        """

        self._images = images

    @property
    def captcha(self):
        """Gets the captcha of this UserNew.  # noqa: E501

        The captcha response is required on public registrations, and ignored when administrators / brokers register another user.  # noqa: E501

        :return: The captcha of this UserNew.  # noqa: E501
        :rtype: CaptchaResponse
        """
        return self._captcha

    @captcha.setter
    def captcha(self, captcha):
        """Sets the captcha of this UserNew.

        The captcha response is required on public registrations, and ignored when administrators / brokers register another user.  # noqa: E501

        :param captcha: The captcha of this UserNew.  # noqa: E501
        :type: CaptchaResponse
        """

        self._captcha = captcha

    @property
    def accept_agreement(self):
        """Gets the accept_agreement of this UserNew.  # noqa: E501

        When there are agreements that need to be accepted for registration, this property must be passed with the value true  # noqa: E501

        :return: The accept_agreement of this UserNew.  # noqa: E501
        :rtype: bool
        """
        return self._accept_agreement

    @accept_agreement.setter
    def accept_agreement(self, accept_agreement):
        """Sets the accept_agreement of this UserNew.

        When there are agreements that need to be accepted for registration, this property must be passed with the value true  # noqa: E501

        :param accept_agreement: The accept_agreement of this UserNew.  # noqa: E501
        :type: bool
        """

        self._accept_agreement = accept_agreement

    @property
    def skip_activation_email(self):
        """Gets the skip_activation_email of this UserNew.  # noqa: E501

        When set to true, the activation e-mail is not sent to the registered user. Can only be used when an administrator / broker is registering a user, and ignored on public registrations (the e-mail is always sent on public registrations).  # noqa: E501

        :return: The skip_activation_email of this UserNew.  # noqa: E501
        :rtype: bool
        """
        return self._skip_activation_email

    @skip_activation_email.setter
    def skip_activation_email(self, skip_activation_email):
        """Sets the skip_activation_email of this UserNew.

        When set to true, the activation e-mail is not sent to the registered user. Can only be used when an administrator / broker is registering a user, and ignored on public registrations (the e-mail is always sent on public registrations).  # noqa: E501

        :param skip_activation_email: The skip_activation_email of this UserNew.  # noqa: E501
        :type: bool
        """

        self._skip_activation_email = skip_activation_email

    @property
    def as_member(self):
        """Gets the as_member of this UserNew.  # noqa: E501

        Flag required only when the authenticated user is a broker,  in that case we need to distingish between registering as member or broker. If true then the new user will be registered without a brokering relationship. Otherwise the authenticated user will be set as the broker of the new user.             # noqa: E501

        :return: The as_member of this UserNew.  # noqa: E501
        :rtype: bool
        """
        return self._as_member

    @as_member.setter
    def as_member(self, as_member):
        """Sets the as_member of this UserNew.

        Flag required only when the authenticated user is a broker,  in that case we need to distingish between registering as member or broker. If true then the new user will be registered without a brokering relationship. Otherwise the authenticated user will be set as the broker of the new user.             # noqa: E501

        :param as_member: The as_member of this UserNew.  # noqa: E501
        :type: bool
        """

        self._as_member = as_member

    @property
    def security_question(self):
        """Gets the security_question of this UserNew.  # noqa: E501

        If the server is configured to use security question, is the `internalName` of the question present in the result of `data-for-new`, in the `securityQuestions` property. Is optional and only used in public registration.             # noqa: E501

        :return: The security_question of this UserNew.  # noqa: E501
        :rtype: str
        """
        return self._security_question

    @security_question.setter
    def security_question(self, security_question):
        """Sets the security_question of this UserNew.

        If the server is configured to use security question, is the `internalName` of the question present in the result of `data-for-new`, in the `securityQuestions` property. Is optional and only used in public registration.             # noqa: E501

        :param security_question: The security_question of this UserNew.  # noqa: E501
        :type: str
        """

        self._security_question = security_question

    @property
    def security_answer(self):
        """Gets the security_answer of this UserNew.  # noqa: E501

        If a `securityQuestion` is informed, this is the answer. Required in this case. Only used in public registration.   # noqa: E501

        :return: The security_answer of this UserNew.  # noqa: E501
        :rtype: str
        """
        return self._security_answer

    @security_answer.setter
    def security_answer(self, security_answer):
        """Sets the security_answer of this UserNew.

        If a `securityQuestion` is informed, this is the answer. Required in this case. Only used in public registration.   # noqa: E501

        :param security_answer: The security_answer of this UserNew.  # noqa: E501
        :type: str
        """

        self._security_answer = security_answer

    @property
    def nfc_token(self):
        """Gets the nfc_token of this UserNew.  # noqa: E501

        If not null then the given NFC token parameters will be used to personalize a tag for the user.  # noqa: E501

        :return: The nfc_token of this UserNew.  # noqa: E501
        :rtype: NfcTokenWithChallengeParameter
        """
        return self._nfc_token

    @nfc_token.setter
    def nfc_token(self, nfc_token):
        """Sets the nfc_token of this UserNew.

        If not null then the given NFC token parameters will be used to personalize a tag for the user.  # noqa: E501

        :param nfc_token: The nfc_token of this UserNew.  # noqa: E501
        :type: NfcTokenWithChallengeParameter
        """

        self._nfc_token = nfc_token

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(UserNew, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, UserNew):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, UserNew):
            return True

        return self.to_dict() != other.to_dict()
