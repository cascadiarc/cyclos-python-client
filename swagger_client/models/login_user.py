# coding: utf-8

"""
    Cyclos 4.11.5 API

    The REST API for Cyclos 4.11.5  # noqa: E501

    OpenAPI spec version: 4.11.5
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


import pprint
import re  # noqa: F401

import six

from swagger_client.configuration import Configuration


class LoginUser(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'user': 'str',
        'password': 'str',
        'remote_address': 'str',
        'channel': 'str',
        'session_timeout': 'TimeInterval'
    }

    attribute_map = {
        'user': 'user',
        'password': 'password',
        'remote_address': 'remoteAddress',
        'channel': 'channel',
        'session_timeout': 'sessionTimeout'
    }

    def __init__(self, user=None, password=None, remote_address=None, channel=None, session_timeout=None, _configuration=None):  # noqa: E501
        """LoginUser - a model defined in Swagger"""  # noqa: E501
        if _configuration is None:
            _configuration = Configuration()
        self._configuration = _configuration

        self._user = None
        self._password = None
        self._remote_address = None
        self._channel = None
        self._session_timeout = None
        self.discriminator = None

        if user is not None:
            self.user = user
        if password is not None:
            self.password = password
        if remote_address is not None:
            self.remote_address = remote_address
        if channel is not None:
            self.channel = channel
        if session_timeout is not None:
            self.session_timeout = session_timeout

    @property
    def user(self):
        """Gets the user of this LoginUser.  # noqa: E501

        The user identification for login. The accepted kind of identification (login name, e-mail, etc) depend on the channel configuration.   # noqa: E501

        :return: The user of this LoginUser.  # noqa: E501
        :rtype: str
        """
        return self._user

    @user.setter
    def user(self, user):
        """Sets the user of this LoginUser.

        The user identification for login. The accepted kind of identification (login name, e-mail, etc) depend on the channel configuration.   # noqa: E501

        :param user: The user of this LoginUser.  # noqa: E501
        :type: str
        """

        self._user = user

    @property
    def password(self):
        """Gets the password of this LoginUser.  # noqa: E501

        The user password. The password type is set in the channel configuration.   # noqa: E501

        :return: The password of this LoginUser.  # noqa: E501
        :rtype: str
        """
        return self._password

    @password.setter
    def password(self, password):
        """Sets the password of this LoginUser.

        The user password. The password type is set in the channel configuration.   # noqa: E501

        :param password: The password of this LoginUser.  # noqa: E501
        :type: str
        """

        self._password = password

    @property
    def remote_address(self):
        """Gets the remote_address of this LoginUser.  # noqa: E501

        The IP address of the user requesting the login.   # noqa: E501

        :return: The remote_address of this LoginUser.  # noqa: E501
        :rtype: str
        """
        return self._remote_address

    @remote_address.setter
    def remote_address(self, remote_address):
        """Sets the remote_address of this LoginUser.

        The IP address of the user requesting the login.   # noqa: E501

        :param remote_address: The remote_address of this LoginUser.  # noqa: E501
        :type: str
        """

        self._remote_address = remote_address

    @property
    def channel(self):
        """Gets the channel of this LoginUser.  # noqa: E501

        The channel internal name. Defaults to `main`.   # noqa: E501

        :return: The channel of this LoginUser.  # noqa: E501
        :rtype: str
        """
        return self._channel

    @channel.setter
    def channel(self, channel):
        """Sets the channel of this LoginUser.

        The channel internal name. Defaults to `main`.   # noqa: E501

        :param channel: The channel of this LoginUser.  # noqa: E501
        :type: str
        """

        self._channel = channel

    @property
    def session_timeout(self):
        """Gets the session_timeout of this LoginUser.  # noqa: E501

        The amount of time the session is valid. The channel configuration has the session timeout, which is the maximum amount of time that can be set. If the given value is higher than the one in the configuration, it will be ignored. Defaults to the timeout set in the configuration.    # noqa: E501

        :return: The session_timeout of this LoginUser.  # noqa: E501
        :rtype: TimeInterval
        """
        return self._session_timeout

    @session_timeout.setter
    def session_timeout(self, session_timeout):
        """Sets the session_timeout of this LoginUser.

        The amount of time the session is valid. The channel configuration has the session timeout, which is the maximum amount of time that can be set. If the given value is higher than the one in the configuration, it will be ignored. Defaults to the timeout set in the configuration.    # noqa: E501

        :param session_timeout: The session_timeout of this LoginUser.  # noqa: E501
        :type: TimeInterval
        """

        self._session_timeout = session_timeout

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(LoginUser, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, LoginUser):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, LoginUser):
            return True

        return self.to_dict() != other.to_dict()
